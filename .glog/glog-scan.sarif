{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "a520bc12-21e7-355b-8488-c47dd905f358",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without any check for a NULL return value. This pattern is dangerous because if malloc fails (e.g., due to memory exhaustion), it returns NULL, and dereferencing this pointer will cause undefined behavior, typically a segmentation fault. There is no evidence of a null guard before the first use, and the first use is a pointer field access, which is considered a dangerous operation. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making the risk assessment more conservative. The pointer is returned and passed to another call, but this does not mitigate the immediate risk of dereferencing a potentially NULL pointer.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the allocated memory. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nlist->next = NULL;\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or clean up\n    return NULL;\n}\nlist->next = NULL;\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, preventing undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "c0bdc3bf-6fb1-34fa-82de-73dc3da1e0b3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of malloc is assigned to 'elem' and is used as a pointer-field dereference without a preceding null check. There is no evidence of a guard that checks whether the allocation succeeded before the pointer is dereferenced or used. This pattern can lead to a null pointer dereference if malloc fails and returns NULL, which is a genuine risk in C/C++ code. The absence of a zero guard, overflow guard, or null guard before use, combined with a dangerous first use (pointer field access), increases the likelihood that this is a real vulnerability. The pointer is also stored in a field and passed to another call, but these do not mitigate the risk of immediate null dereference.\n\n## In Context Remediation\nTo prevent a null pointer dereference after a failed memory allocation, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nelem->next = ...; // unsafe if malloc failed\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nif (elem == NULL) {\n    // Handle allocation failure, e.g., return an error or clean up\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "2ac6931a-0eca-3404-abc8-060a2a8967ef",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of malloc is assigned to 'elem' and is used as a pointer-field dereference without a preceding null check. There is no evidence of a guard that checks whether the allocation succeeded before the pointer is dereferenced or used. This pattern can lead to a null pointer dereference if malloc fails and returns NULL, which is a well-known source of runtime errors and potential security vulnerabilities. The absence of zero guards, overflow guards, and null checks, combined with the immediate use of the allocated pointer, increases the risk of a genuine vulnerability. The classification and call verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nAlways check the result of malloc before using the allocated pointer. If malloc returns NULL, handle the error appropriately (e.g., by returning an error code, logging, or cleaning up). For example, if your original code is:\n\n```c\ncustom_match_prq_node *elem = malloc(sizeof(custom_match_prq_node));\nelem->next = ...; // unsafe if elem is NULL\n```\n\nA safe version would be:\n\n```c\ncustom_match_prq_node *elem = malloc(sizeof(custom_match_prq_node));\nif (elem == NULL) {\n    // Handle allocation failure: log, cleanup, or return error\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use\n```\n\nThis ensures that the pointer is only dereferenced if the allocation succeeded, preventing null pointer dereference vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "05d5468d-cd8c-3a46-95af-5a7e30e2f7ee",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without a preceding check for NULL. There is no zero guard or overflow guard present, and the first use is a potentially dangerous dereference (ptr-field) with no null guard before use. The pointer is also returned and passed to another call, increasing the risk of propagating a NULL pointer. These factors indicate a genuine risk of null pointer dereference if malloc fails, which can lead to undefined behavior or crashes. The absence of a cast does not mitigate the risk. The classification and call verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nlist->next = NULL; // unsafe if malloc fails\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or clean up\n    return NULL;\n}\nlist->next = NULL; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "18a2966d-3ac5-32ea-b58d-041aa3f5e974",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The first use of the allocated pointer is a potentially dangerous operation (ptr-field) and there is no null guard before this use. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making it harder to reason about safety. The pointer is returned and passed to another call, but these do not mitigate the risk of a null dereference. The call verdict is 'GENUINE', confirming this is a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after a failed malloc, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nlist->field = ...; // unsafe if malloc fails\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or cleanup\n    return NULL;\n}\nlist->field = ...; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "aa0da565-8353-3a7b-a56a-0db467db118e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The absence of a null guard before the first use of the allocated pointer increases the risk of a null dereference if memory allocation fails. The first use is a potentially dangerous pointer field access, and there are no zero guards or overflow guards present. The pointer is also stored in a field and passed to another call, which can propagate the risk. These factors indicate a genuine vulnerability, specifically a possible null pointer dereference after a failed memory allocation.\n\n## In Context Remediation\nAlways check the result of malloc for NULL before using the allocated pointer. If malloc fails, handle the error appropriately (e.g., return an error code, log the failure, or clean up resources). For example, if your original code is:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nelem->next = ...; // unsafe if elem is NULL\n```\n\nA safe remediation would be:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nif (elem == NULL) {\n    // Handle allocation failure (e.g., return error, log, etc.)\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use elem\n```\n\nThis ensures that the pointer is only dereferenced if the allocation succeeded, preventing a possible null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "79cbefea-e49d-3b47-9f32-43371426a25d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The absence of a null guard before the first use of the allocated pointer increases the risk of a null pointer dereference if memory allocation fails. The first use is a pointer field access, which is considered dangerous if the pointer is not validated. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making the allocation less obviously safe. The pointer is also stored in a field and passed to another call, but these do not mitigate the risk of dereferencing a null pointer. The call verdict is 'GENUINE', confirming this is a real issue.\n\n## In Context Remediation\nTo prevent a null pointer dereference after memory allocation, always check the result of malloc before using the allocated pointer. For example, after:\n\n```c\nelem = malloc(sizeof(custom_match_prq_node));\n```\nadd a null check before using `elem`:\n\n```c\nif (elem == NULL) {\n    // Handle allocation failure, e.g., return an error or clean up\n    return ERROR_CODE;\n}\n```\nThis ensures that if malloc fails and returns NULL, the code does not attempt to access fields or use the pointer, preventing undefined behavior or crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "6377e878-8009-3d0d-8f66-3d682ef4bb7a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without any check for a NULL return value. This is a common source of null pointer dereference vulnerabilities, especially if malloc fails and returns NULL. There is no evidence of a guard (such as an if-statement) checking whether the allocation succeeded before the pointer is dereferenced. The first use is a potentially dangerous pointer field access, and no null guard is present before this use. The function returns the pointer and also passes it to another call, which increases the risk if the allocation fails. These factors indicate a genuine vulnerability with a low probability of being a false positive.\n\n## In Context Remediation\nAlways check the result of malloc before using the allocated pointer. If malloc returns NULL, handle the error appropriately (e.g., return an error code, log the failure, or clean up resources). For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nlist->field = ...; // unsafe: possible null dereference\n```\n\nA safe version would be:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nif (list == NULL) {\n    // Handle allocation failure (e.g., return NULL, log error, etc.)\n    return NULL;\n}\nlist->field = ...; // safe: list is guaranteed non-null\n```\n\nThis ensures that the pointer is not dereferenced if the allocation fails, preventing undefined behavior and potential security vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "58540b10-62b7-3153-a9ed-365d65f9fabe",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination buffers in a memory copy operation. The code copies data from one buffer to another using a function that does not handle overlapping memory regions safely. Dataflow analysis indicates that the source and destination may refer to overlapping memory, which can cause unpredictable results or crashes. Additionally, there is no evidence of a guard to prevent this, and the source may also be null, increasing the risk. The destination is a pointer with unknown capacity, and the count is not proven safe. These factors all contribute to the high confidence in this being a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` is specifically designed to handle overlapping source and destination buffers safely.\n\n```c\nmemmove(version, tmp, strlen(tmp) + 1);\n```\n\nAdditionally, ensure that both `version` and `tmp` are not null before performing the copy to avoid null pointer dereference:\n\n```c\nif (version != NULL && tmp != NULL) {\n    memmove(version, tmp, strlen(tmp) + 1);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708",
                  "58540b10-62b7-3153-a9ed-365d65f9fabe"
                ]
              }
            },
            {
              "id": "09701811-c9dd-3480-b2ec-91d4d73f6e53",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow or other undefined behavior.\n\nIn the provided code snippet, `*resultlen = strlen(tmp) + 1`, there is no check to ensure that `tmp` is a null-terminated string. This could lead to a buffer overflow vulnerability if `tmp` does not contain a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `strnlen`:\n\n```cpp\nsize_t max_length = 100; // Replace with the maximum expected length of tmp\n*resultlen = strnlen(tmp, max_length) + 1;\n```\n\nIn this version, `strnlen` will stop reading `tmp` after `max_length` characters, even if it has not encountered a null character. This prevents a potential buffer overflow.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4f04d746-66af-36e4-a13d-40e9358e1580",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `strlen` function in C++. This function returns the length of a string, not including the null-terminating character. If the string is not null-terminated, `strlen` can return a value that is larger than the actual size of the string, leading to a buffer overflow when the string is copied using `memcpy`.\n\nThis vulnerability can lead to various security issues, including denial of service, code execution, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated before using `strlen`. Additionally, you should avoid using `memcpy` to copy strings, as it does not check for null-termination and can lead to buffer overflows. Instead, use safer functions like `strncpy` or `strlcpy`, which take the size of the destination buffer as an argument and ensure that the copied string is null-terminated.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nstrncpy(version, tmp, sizeof(version) - 1);\nversion[sizeof(version) - 1] = '\\0';\n```\n\nIn this code, `strncpy` is used to copy the string, and the size of the destination buffer is passed as an argument to prevent buffer overflows. The last line ensures that the copied string is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021",
                  "4f04d746-66af-36e4-a13d-40e9358e1580"
                ]
              }
            },
            {
              "id": "4419b943-13ca-376e-b726-65bd7f1d1a06",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the vulnerability arises if the `tmp` string is not null-terminated. This could lead to `strlen(tmp)` returning a value larger than expected, which could in turn lead to negative values for `len_left`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Ensure tmp is null-terminated\ntmp[sizeof(tmp) - 1] = '\\0';\n\n// Use strnlen instead of strlen\nlen_left = OSHMEM_MAX_LIBRARY_VERSION_STRING - strnlen(tmp, OSHMEM_MAX_LIBRARY_VERSION_STRING);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2a3f7eaa-854b-3e1d-83a0-1ae48674cc0e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to a buffer overflow.\n\nIn the provided code snippet `strlen(OSHMEM_RELEASE_DATE) > 0`, the vulnerability arises if `OSHMEM_RELEASE_DATE` is not a null-terminated string. This could lead to a buffer overflow, causing the program to crash or behave unexpectedly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated. This can be done by initializing strings with a null character or by manually adding a null character at the end of the string.\n\n## Source Code Fix Recommendation\n\nEnsure `OSHMEM_RELEASE_DATE` is a null-terminated string. If `OSHMEM_RELEASE_DATE` is a character array, you can initialize it with a null character:\n\n```cpp\nchar OSHMEM_RELEASE_DATE[] = \"release_date\\0\";\n```\n\nIf `OSHMEM_RELEASE_DATE` is a string that is being modified, ensure a null character is added at the end:\n\n```cpp\nOSHMEM_RELEASE_DATE[length_of_string] = '\\0';\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++), so no additional libraries are needed for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-119)](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "fabd22dd-0f46-3a8a-8174-a1e643f61b13",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr = tmp + strlen(tmp)`, the vulnerability arises if `tmp` is not a null-terminated string. This could lead to `strlen(tmp)` reading beyond the allocated memory for `tmp`, causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read beyond a certain point in memory.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr = tmp + len;\n```\n\nIn this version, `strnlen()` is used instead of `strlen()`, with `MAX_LEN` as the maximum number of characters to read. This ensures that `strnlen()` does not read beyond `MAX_LEN` characters, preventing buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "48bb2fae-0c81-380f-9607-91c504e32c97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the vulnerability arises if the `tmp` string is not null-terminated. This could lead to `strlen(tmp)` returning a value larger than expected, which could in turn lead to negative values for `len_left`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Ensure tmp is null-terminated\ntmp[sizeof(tmp) - 1] = '\\0';\n\n// Use strnlen instead of strlen\nlen_left = OSHMEM_MAX_LIBRARY_VERSION_STRING - strnlen(tmp, OSHMEM_MAX_LIBRARY_VERSION_STRING);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "a8fbf458-774e-3392-ad75-8f2429750ba4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the vulnerability arises if the `tmp` string is not null-terminated. This could lead to `strlen(tmp)` returning a value larger than expected, which could in turn lead to negative values for `len_left`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Ensure tmp is null-terminated\ntmp[sizeof(tmp) - 1] = '\\0';\n\n// Use strnlen instead of strlen\nlen_left = OSHMEM_MAX_LIBRARY_VERSION_STRING - strnlen(tmp, OSHMEM_MAX_LIBRARY_VERSION_STRING);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "32d6ef63-79d1-340d-8aca-2fbca7da2f6f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr = tmp + strlen(tmp)`, the vulnerability arises if `tmp` is not a null-terminated string. This could lead to `strlen(tmp)` reading beyond the allocated memory for `tmp`, causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read beyond a certain point in memory.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr = tmp + len;\n```\n\nIn this version, `strnlen()` is used instead of `strlen()`, with `MAX_LEN` as the maximum number of characters to read. This ensures that `strnlen()` does not read beyond `MAX_LEN` characters, preventing buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "19c3cbc7-f86e-3c6f-bee6-4832df848e04",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr = tmp + strlen(tmp)`, the vulnerability arises if `tmp` is not a null-terminated string. This could lead to `strlen(tmp)` reading beyond the allocated memory for `tmp`, causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read beyond a certain point in memory.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr = tmp + len;\n```\n\nIn this version, `strnlen()` is used instead of `strlen()`, with `MAX_LEN` as the maximum number of characters to read. This ensures that `strnlen()` does not read beyond `MAX_LEN` characters, preventing buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c6867226-126c-3bdd-8e41-5b180d665822",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the vulnerability arises if the `tmp` string is not null-terminated. This could lead to `strlen(tmp)` returning a value larger than expected, which could in turn lead to negative values for `len_left`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Ensure tmp is null-terminated\ntmp[sizeof(tmp) - 1] = '\\0';\n\n// Use strnlen instead of strlen\nlen_left = OSHMEM_MAX_LIBRARY_VERSION_STRING - strnlen(tmp, OSHMEM_MAX_LIBRARY_VERSION_STRING);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "eb3e21d5-bc8b-3576-be80-7af14a8d88c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr = tmp + strlen(tmp)`, the vulnerability arises if `tmp` is not a null-terminated string. This could lead to `strlen(tmp)` reading beyond the allocated memory for `tmp`, causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read beyond a certain point in memory.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr = tmp + len;\n```\n\nIn this version, `strnlen()` is used instead of `strlen()`, with `MAX_LEN` as the maximum number of characters to read. This ensures that `strnlen()` does not read beyond `MAX_LEN` characters, preventing buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "052e7ef5-c407-3229-82de-4daf3372d450",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, the vulnerability arises if the `tmp` string is not null-terminated. This could lead to `strlen(tmp)` returning a value larger than expected, which could in turn lead to negative values for `len_left`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter to prevent reading past the end of the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\n```cpp\n// Ensure tmp is null-terminated\ntmp[sizeof(tmp) - 1] = '\\0';\n\n// Use strnlen instead of strlen\nlen_left = OSHMEM_MAX_LIBRARY_VERSION_STRING - strnlen(tmp, OSHMEM_MAX_LIBRARY_VERSION_STRING);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3b9a50a0-f300-3389-b46f-b9f2df3f8235",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr = tmp + strlen(tmp)`, the vulnerability arises if `tmp` is not a null-terminated string. This could lead to `strlen(tmp)` reading beyond the allocated memory for `tmp`, causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read beyond a certain point in memory.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr = tmp + len;\n```\n\nIn this version, `strnlen()` is used instead of `strlen()`, with `MAX_LEN` as the maximum number of characters to read. This ensures that `strnlen()` does not read beyond `MAX_LEN` characters, preventing buffer overflows.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7266bb1f-1d98-3057-8a61-524129fc51ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet `strlen(OSHMEM_IDENT_STRING) > 0`, the vulnerability arises if `OSHMEM_IDENT_STRING` is not a null-terminated string. This could lead to a buffer overflow vulnerability, causing the program to crash or leading to execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen()` function with `strnlen()`. The second parameter to `strnlen()` should be the maximum expected length of `OSHMEM_IDENT_STRING`. If `OSHMEM_IDENT_STRING` is longer than this value, `strnlen()` will stop reading and return the maximum length.\n\n```cpp\nstrnlen(OSHMEM_IDENT_STRING, MAX_LENGTH) > 0\n```\n\nReplace `MAX_LENGTH` with the maximum expected length of `OSHMEM_IDENT_STRING`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++), so no additional libraries are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3e913550-e3d0-3f87-8c4d-5dd84c3fc18b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other vulnerabilities.\n\nIn the provided code snippet `strlen(OSHMEM_REPO_REV) > 0`, the vulnerability arises if `OSHMEM_REPO_REV` is not a null-terminated string. This could lead to undefined behavior, including reading beyond the allocated memory, which can cause a crash or other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings passed to `strlen()` are null-terminated. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string before passing it to `strlen()`.\n\n## Source Code Fix Recommendation\n\nEnsure `OSHMEM_REPO_REV` is a null-terminated string. If `OSHMEM_REPO_REV` is a character array, you can ensure it is null-terminated by initializing it with a null character:\n\n```cpp\nchar OSHMEM_REPO_REV[] = \"some_string\\0\";\n```\n\nIf `OSHMEM_REPO_REV` is a pointer to a string, you can add a null character to the end of the string:\n\n```cpp\nchar* OSHMEM_REPO_REV = new char[length + 1];\nstrcpy(OSHMEM_REPO_REV, \"some_string\");\nOSHMEM_REPO_REV[length] = '\\0';\n```\n\nThen, you can safely use `strlen()`:\n\n```cpp\nif (strlen(OSHMEM_REPO_REV) > 0) {\n    // ...\n}\n```\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so the code requires the `<cstring>` (or `<string.h>` in C) library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "c9582433-e079-3a8d-8606-efa4b4db57d3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(OPAL_PACKAGE_STRING) > 0`, the vulnerability arises if `OPAL_PACKAGE_STRING` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives that take the size of the buffer as an argument, such as `strnlen()`, which will not read past the specified length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(OPAL_PACKAGE_STRING) > 0` with `strnlen(OPAL_PACKAGE_STRING, MAX_LENGTH) > 0`, where `MAX_LENGTH` is the maximum expected length of `OPAL_PACKAGE_STRING`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so no additional libraries are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3fb1b2eb-7b87-3100-9917-8cae2b555994",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `ptr += strlen(tmp)`, if `tmp` is not null-terminated, it can lead to the aforementioned issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings.\n\nAlso, consider using safer alternatives to `strlen`, such as `strnlen`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the buffer.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code snippet using `strnlen`:\n\n```cpp\nsize_t len = strnlen(tmp, MAX_LEN);\nptr += len;\n```\n\nIn this code, `MAX_LEN` is the maximum number of characters that `strnlen` will read. You should replace `MAX_LEN` with the actual size of the `tmp` buffer.\n\n## Library Dependencies\n\nThe code example requires the `cstring` library, which provides the `strlen` and `strnlen` functions.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e98feb63-e81d-3d6f-9f8a-f1260b0873fd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(OSHMEM_GREEK_VERSION) > 0`, the vulnerability arises if `OSHMEM_GREEK_VERSION` is not a null-terminated string. This could lead to a buffer overflow vulnerability, which can be exploited to execute arbitrary code, crash the program, or lead to information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that all strings are null-terminated before passing them to `strlen()`. If the string comes from an untrusted source, validate and sanitize the input before using it. Avoid using `strlen()` on strings of unknown length or origin.\n\n## Source Code Fix Recommendation\n\nEnsure `OSHMEM_GREEK_VERSION` is a null-terminated string. If it's a string literal, it's automatically null-terminated. If it's a character array, ensure it's properly initialized with a null character at the end. If it's a pointer to a string, make sure the string it points to is null-terminated.\n\n```cpp\n// If OSHMEM_GREEK_VERSION is a character array, ensure it's null-terminated\nchar OSHMEM_GREEK_VERSION[] = \"some version\\0\";\n\n// If OSHMEM_GREEK_VERSION is a pointer, ensure it points to a null-terminated string\nchar* OSHMEM_GREEK_VERSION = new char[15];\nstrcpy(OSHMEM_GREEK_VERSION, \"some version\\0\");\n```\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen()` function.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "8043097d-200f-3753-bfe6-8116e32977e5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other security issues.\n\nIn the provided code snippet, the vulnerability arises if `tmp` is not a null-terminated string. This can lead to an incorrect calculation of `len_left`, potentially causing a buffer overflow or underflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings.\n\nAdditionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows by ensuring that `strlen()` does not read past the end of your string.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\n#include <string.h> // for strnlen()\n\nsize_t max_len = 100; // replace with the maximum expected length of tmp\nlen_left -= strnlen(tmp, max_len);\n```\n\nIn this code, `strnlen()` will stop reading `tmp` after `max_len` characters, preventing a potential buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0322d5fa-041b-3967-ba18-4b2f40850427",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. This function is used to calculate the length of a string. The vulnerability arises when the function is used without proper validation of the input. If the input string is not null-terminated, `strlen` can lead to buffer over-read, causing undefined behavior, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the string passed to `strlen` is null-terminated. This can be done by initializing strings with a null character or by manually adding a null character at the end of the string before passing it to `strlen`.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (p != NULL && 16 < strlen(p)) {\n    // Your code here\n}\n```\n\nIn this code, we first check if `p` is not `NULL` before passing it to `strlen`. This ensures that `strlen` is not called with a `NULL` pointer, which would cause undefined behavior.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "cc95f32f-0f82-32cb-b719-69bf7a970032",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This string can be overwritten by subsequent calls to `getenv`, which can lead to race conditions if the application is multithreaded.\n\n## Mitigation Advice\n\nAvoid using the `getenv` function in multithreaded applications. If you need to use environment variables, consider using a method that is thread-safe. Also, validate the input and output of all C functions to ensure they are within the expected range.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, consider using a thread-safe alternative such as `getenv_s`:\n\n```cpp\nchar* p1;\nsize_t len;\n_dupenv_s(&p1, &len, SHMEM_HEAP_SIZE);\nif (NULL != p1) {\n    // ...\n}\nfree(p1);\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "241cbf32-a080-3105-8546-d104eaf9dac9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to security vulnerabilities. The `getenv` function returns a pointer to a string that is associated with the matched environment variable name. This string can be overwritten by subsequent calls to `getenv`, `setenv`, or `putenv`.\n\n## Mitigation Advice\n\nAvoid using `getenv` function as it is not thread-safe and can lead to race conditions. Instead, use secure alternatives like `getenv_s` or `secure_getenv` if available. Also, ensure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\n```cpp\nchar *cptr;\nsize_t len;\n_dupenv_s(&cptr, &len, SHMEM_HEAP_SIZE);\nif (NULL != cptr) {\n    // your code here\n    free(cptr);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstdlib` (for `getenv` and `NULL`)\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0bbe6dae-28dd-3108-9719-92e481a70721",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `getenv()` is considered unsafe because it returns a pointer to a string that represents the value for the specified environment variable, which can be manipulated by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv()` function as it is not thread-safe and can be exploited to cause race conditions. Instead, consider using safer alternatives such as `getenv_s()` or `getenv_r()`. Also, ensure to validate and sanitize all inputs and outputs.\n\n## Source Code Fix Recommendation\n\nReplace the `getenv()` function with a safer alternative. Here is an example of how you can do it:\n\n```cpp\nchar *cptr;\nsize_t len;\n_dupenv_s(&cptr, &len, OSHMEM_ENV_DEBUG);\nif (NULL != cptr) {\n    // your code here\n    free(cptr);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstdlib` (for `getenv()` function)\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9153c36d-0551-38a2-a63e-843a6d3e9855",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can be exploited by an attacker to manipulate the environment variables and cause unexpected behavior in the program.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using a safer method to retrieve environment variables. Also, validate and sanitize all inputs and outputs. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for std::getenv\n#include <cstring> // for std::strcmp\n\nchar* cptr;\nconst char* env_var = std::getenv(\"OSHMEM_ENV_SYMMETRIC_SIZE\");\nif (env_var != nullptr)\n{\n    cptr = new char[std::strlen(env_var) + 1];\n    std::strcpy(cptr, env_var);\n}\nelse\n{\n    // Handle the case when the environment variable is not set\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetics, searching, sorting and converting.\n\n- `<cstring>`: This header defines several functions to manipulate C strings and arrays.\n\n## OWASP Resources\n\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0b4bdfb5-50c5-37f8-b336-cc5f14ac3f40",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv()` function is used, which can lead to potential security risks. The `getenv()` function returns a pointer to a string that is associated with the matched environment variable name. This can lead to information disclosure or potential code execution if the environment variable is controlled by an attacker.\n\n## Mitigation Advice\n\nAvoid using `getenv()` function as it is not thread-safe and can lead to race conditions. Instead, consider using `secure_getenv()` or `getenv_s()`, which are safer alternatives. Also, always validate and sanitize the input and output data.\n\n## Source Code Fix Recommendation\n\nReplace the `getenv()` function with `secure_getenv()` or `getenv_s()`. Here is an example of how to use `getenv_s()`:\n\n```cpp\nchar* buffer;\nsize_t bufferSize;\n_getenv_s(&bufferSize, NULL, 0, OSHMEM_ENV_INFO);\nbuffer = (char*) malloc(bufferSize);\n_getenv_s(&bufferSize, buffer, bufferSize, OSHMEM_ENV_INFO);\nif (NULL != buffer) {\n    cptr = buffer;\n}\nfree(buffer);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: This library is required for the `getenv()`, `secure_getenv()`, and `getenv_s()` functions.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ebafda49-3025-39c6-a044-e770c1287bf8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `getenv` function is used, which can lead to environment variable vulnerabilities. This function returns a pointer to a string that represents the value for the environment variable passed in. If the environment variable is not found, the function returns a null pointer. This can lead to null pointer dereferencing if not properly checked.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, consider using a method that does not involve direct access to environment variables, or ensure that the environment variable is properly sanitized and validated before use.\n\n## Source Code Fix Recommendation\n\nCheck if the pointer returned by `getenv` is null before using it:\n\n```cpp\nchar* cptr = getenv(OSHMEM_ENV_VERSION);\nif (cptr != NULL) {\n    // use cptr\n} else {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `cstdlib` library for the `getenv` function.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "73003818-f60a-3e31-912d-4313942d3070",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strcpy` and instead use safer alternatives that check the size of the destination buffer. These include functions like `strncpy`, `strlcpy`, or `memcpy`. However, these functions also have their own caveats and must be used correctly to avoid vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(error_buf, \"Unknown error\", sizeof(error_buf) - 1);\nerror_buf[sizeof(error_buf) - 1] = '\\0';\n```\n\nThis code will copy the string \"Unknown error\" into `error_buf`, but it will not exceed the size of `error_buf`. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "6f35c391-2324-3eb3-b83b-93953d477ef5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is used to copy the content of one string to another. However, it is considered a dangerous function as it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(error_buf, error, sizeof(error_buf));\nerror_buf[sizeof(error_buf) - 1] = '\\0'; // Ensure null-termination\n```\n\nThis code will copy at most `sizeof(error_buf)` characters from `error` to `error_buf`, and ensures that `error_buf` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "ac73c548-2b6b-3575-838e-8f06d9602944",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strcpy` and instead use safer alternatives that check the size of the destination buffer. These include functions like `strncpy`, `strlcpy`, or `memcpy`. However, these functions also have their own caveats and must be used correctly to avoid vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(error, \"Memory allocation failure\", sizeof(error) - 1);\nerror[sizeof(error) - 1] = '\\0';\n```\n\nThis code will copy the string to the `error` buffer, but it will not exceed the size of the buffer. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "69ad8698-efb1-3cec-909d-5a1ce46d644c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which can cause undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, which further increases the risk. The destination is not a pointer-based member, suggesting it is likely a local or struct field, but this does not mitigate the overlap risk. The classification and verdict both indicate a real issue that should be addressed to prevent potential memory corruption or unpredictable program behavior.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. For example, replace the original call with:\n\n```c\nmemmove(&state.settings, settings, sizeof(json_settings));\n```\n\nAdditionally, consider adding a check to ensure that the source pointer is not null before performing the copy:\n\n```c\nif (settings != NULL) {\n    memmove(&state.settings, settings, sizeof(json_settings));\n}\n```\n\nThis approach eliminates the undefined behavior risk associated with overlapping memory regions and null pointers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f5ea93f0-e1e1-3830-8c9e-3563b70eab6e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The analysis detected that the source and destination may refer to overlapping memory through data flow, which can cause unpredictable results with memcpy. Additionally, there are no explicit checks or guards in the code to prevent this overlap, and the source pointer could potentially be null, further increasing the risk. The destination is a pointer with unknown capacity, and there is no evidence that the length argument is safely bounded. All these factors contribute to the high confidence in this being a real issue that could lead to memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```c\nmemmove(base, *source, len);\n```\n\nThis change ensures that the copy operation is safe even if the source and destination regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "04388287-058b-3db8-b7a0-9c761950935d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'High Risk' because the calloc call uses a product expression for the allocation size (nmemb * size), but there are no zero guards or overflow guards present. This can lead to integer overflow, resulting in a buffer that is smaller than intended, which is a well-known security vulnerability. The absence of a left-hand side variable (lhsVar) suggests the result may not be used, but the risk remains due to the unchecked multiplication. The call verdict is 'GENUINE', confirming this is a real issue. No mitigating factors such as guards or safe types are present.\n\n## In Context Remediation\nTo prevent integer overflow in the allocation size calculation, always check that the multiplication of the number of elements and the size of each element does not exceed the maximum value representable by size_t. You can do this by adding an explicit check before the calloc call:\n\n```c\nif (size != 0 && SIZE_MAX / size < 1) {\n    // Handle overflow error, e.g., return NULL or set an error code\n} else {\n    void *ptr = calloc(1, size);\n    // Use ptr safely\n}\n```\nThis ensures that the multiplication will not wrap around and cause a buffer smaller than intended to be allocated, which could lead to buffer overflows or other memory safety issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "d68713bf-4373-3d89-a9ec-dd866e2c3572",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination may overlap, which can result in undefined behavior according to the C standard. The analysis detected that the source and destination may refer to overlapping memory regions due to data flow between them. Additionally, there is no evidence of a guard or check to prevent this overlap. The source may also be null, which could lead to a null pointer dereference. These factors indicate a real risk of undefined behavior and potential security issues such as memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely. Replace the original call with:\n\n```c\nmemmove(*dest, base, len);\n```\n\nAdditionally, ensure that both `*dest` and `base` are not null before performing the operation:\n\n```c\nif (*dest != NULL && base != NULL) {\n    memmove(*dest, base, len);\n}\n```\n\nThis change eliminates the risk of undefined behavior due to overlapping memory and null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "391c6c2f-b32e-3b4c-8180-8853e1125f0f",
              "help": {
                "text": "",
                "markdown": "The finding is classified as 'Needs Manual Review', which means it is not automatically considered a genuine vulnerability. The malloc call allocates memory using a potentially non-literal and unchecked size expression ('*max_datatypes * sizeof(MPI_Datatype)'), and there are no explicit zero or overflow guards detected. However, the first use of the allocated pointer is to pass it to another function, and a null check is present before this use, which reduces the risk of a null dereference. The presence of a cast is noted but does not significantly increase risk. Since the classification requires manual review and the null guard is present, this is likely not a genuine vulnerability, but further manual inspection is recommended to ensure that size calculations and ownership are handled safely.\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "9a64283f-4b0a-36b3-af3d-e229000f8cb0",
              "help": {
                "text": "",
                "markdown": "This finding involves a call to `malloc` with a computed size expression (`*max_datatypes * sizeof(MPI_Datatype)`) and a cast. The classification indicates that manual review is needed to verify the presence of null checks, size guards, and correct ownership handling. The following factors influenced the decision:\n\n- The first use of the allocated pointer is benign (`passed-to-call`), which reduces the risk of immediate null dereference or buffer overflow.\n- A null guard is present before the first use, which is a positive safety signal.\n- There are no explicit zero guards or overflow guards detected, and the size expression is not a simple pattern, so manual review is warranted to ensure that integer overflows or zero-size allocations are not possible.\n- The function verdict is 'REVIEW', matching the call verdict, which further supports the need for human inspection rather than automated classification as a vulnerability.\n\nOverall, while there are some positive safety signals, the lack of explicit guards and the complex size expression mean that this is not automatically classified as a vulnerability, but it is not clearly safe either. Manual review is recommended.\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "4d7a9e8e-fe49-35d8-ac21-0f42d127b4b6",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Needs Manual Review', which means it is not automatically considered a genuine vulnerability. The malloc call allocates memory for an array of MPI_Datatype objects, with the size expression being '*max_datatypes * sizeof(MPI_Datatype)'. The first use of the allocated pointer is to pass it to another function, and there is a null guard present before this use, which is a positive safety signal. However, there are no explicit zero guards or overflow guards on the allocation size, and the size expression is not a simple literal or sizeof(T) pattern, which increases the risk of subtle bugs if *max_datatypes is not properly validated elsewhere. The presence of a cast is typical in C code but does not significantly affect safety. Overall, while there are some positive safety signals, the lack of explicit guards and the need for manual review of the size calculation and ownership handling means this is not a clear false positive, but also not a confirmed vulnerability.\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "6cfabbbe-c533-3242-8dd0-5110ce9c1e1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the function in question is `memmove()`. This function is used to copy a block of memory from one location to another and it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that include bounds checking to prevent buffer overflow. In C++, this could be achieved by using standard library functions or classes that automatically manage memory, such as `std::vector` or `std::string`.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove()` function with a safer alternative. For example, if `buffer` and `ptr` are arrays or vectors of a certain type, you could use `std::copy()` from the `<algorithm>` library, which checks the bounds of the destination:\n\n```cpp\n#include <algorithm>\n\n// Assuming buffer and ptr are of type std::vector<char> or similar\nstd::copy(ptr, ptr + read_offset, buffer.begin());\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `memmove()` function.\n\n## OWASP and CWE Links\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ccd0dfeb-9b69-33a2-885e-c65a1455afaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using safer alternatives that take the size of the buffer as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nread_offset = strlen(ptr);\n```\n\nYou could use:\n\n```cpp\nread_offset = strnlen(ptr, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen` from reading past the end of the buffer.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "deb3cc19-78b0-3a65-a972-d07e305df24b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to buffer overflow vulnerabilities if not used properly. In the provided code snippet, the `strlen` function is used without checking if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading until it finds a null character, potentially reading past the end of the buffer and causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (!addr || addr + 3 > distances[i].uuid + (distances[i].uuid ? strnlen(distances[i].uuid, MAX_UUID_LENGTH) : 0))\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length `MAX_UUID_LENGTH` is provided to prevent reading past the end of the buffer. Additionally, a check is added to ensure `distances[i].uuid` is not null before calling `strnlen`.\n\n## Library Dependencies\n\nThe code snippet does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4c43e63f-701d-3bd3-92e3-1135a4b4e791",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used carefully. In the provided code snippet, `strlen(list[i])` is used as the maximum number of characters to compare in the `strncasecmp` function. If `list[i]` is shorter than `item`, this can lead to reading beyond the end of `list[i]`, which is undefined behavior and can potentially be exploited.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that you are not reading beyond the end of the string. This can be done by comparing the lengths of the strings before using them in the `strncasecmp` function. If `item` is longer than `list[i]`, you should not proceed with the comparison.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability:\n\n```cpp\nif (strlen(item) >= strlen(list[i])) {\n    if (0 == strncasecmp(item, list[i], strlen(list[i]))) {\n        // ...\n    }\n}\n```\n\nIn this code, we first check if `item` is longer than or equal to `list[i]`. If it is, we proceed with the `strncasecmp` comparison. This ensures that we are not reading beyond the end of `list[i]`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `strlen` and `strncasecmp` functions.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4ce55ee2-c447-35c3-85ab-074f1fbc43e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when handling user input or data from untrusted sources. Consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(input);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(input, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of your string. This ensures that `strnlen` will not read past `MAX_LEN` characters, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so you need to include the `cstring` header:\n\n```c++\n#include <cstring>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e0159aef-10e2-3382-825b-92badd0d4b79",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in this code snippet is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This can lead to buffer overflows if the string is not properly null-terminated, which can lead to crashes, data corruption, and potential security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include bounds checking, such as `strnlen` or `strncpy`. These functions will prevent buffer overflows by ensuring that the string does not exceed a specified length.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet:\n\n```cpp\nprev_prov && !strncasecmp(prev_prov->fabric_attr->prov_name, name, strnlen(name, MAX_NAME_LENGTH))\n```\n\nIn this fix, `strnlen` is used instead of `strlen`. `MAX_NAME_LENGTH` is a predefined constant that specifies the maximum length of the string `name`.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `string.h`: This library is required for the `strncasecmp` and `strlen` functions.\n- `fi_prov.h`: This library is assumed to be required for the `prev_prov->fabric_attr->prov_name` object.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "74c48fc3-ccec-3968-8bae-b5f2a29dec11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen` such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\ndestdir_offset = strlen(destdir);\n```\n\nConsider using:\n\n```cpp\ndestdir_offset = strnlen(destdir, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `destdir`. This ensures that `strnlen` will not read past `MAX_LENGTH`, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "df25b02b-891e-3cda-a2b8-5d77c9ec4fec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, it can lead to a vulnerability if the string is not null-terminated or if the string is `NULL`. In the provided code snippet, `strlen(destdir)` is called without checking if `destdir` is `NULL` or not. If `destdir` is `NULL`, the `strlen` function will cause a segmentation fault, leading to a crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the string passed to `strlen` is not `NULL`. This can be done by adding an additional check before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (NULL != destdir) {\n    if (destdir[0] != '\\0') {\n        // rest of the code\n    }\n}\n```\n\nIn this fixed code, we first check if `destdir` is not `NULL`. Then, we check if the first character of `destdir` is not the null character (`'\\0'`). This ensures that `destdir` is not `NULL` and is not an empty string.\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "1b9df3e9-0b5d-3f22-8147-7003b91e3b9c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the null-terminating character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other memory corruption issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen`, use `strnlen` with a maximum length parameter:\n\n```cpp\nstrnlen(\"@{\" #fieldname \"}\", MAX_LENGTH);\n```\n\nReplace `MAX_LENGTH` with the maximum expected length of the string. This ensures that `strnlen` will not read past the end of the string, even if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "75414095-8db6-3dff-ba1a-e7d2a0f87128",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dd4f8618-b241-32fc-abb7-e755939860fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but can be overwritten by a subsequent call to `getenv()`, `putenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, instead of `getenv()`, consider using a method that does not allow for potential overwrites or modifications. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string destdir;\nconst char* tmp = std::getenv(\"OPAL_DESTDIR\");\nif(tmp != nullptr) {\n    destdir = tmp;\n}\n```\n\nIn this code, we are still using `getenv()`, but we immediately copy the result into a `std::string`. This way, even if a subsequent call to `getenv()`, `putenv()`, `setenv()`, or `unsetenv()` overwrites the original data, our copy remains valid.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- string\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44190b36-699f-3917-910f-4ee3174d05db",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "a520bc12-21e7-355b-8488-c47dd905f358",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 452,
                  "startColumn": 29,
                  "endLine": 452,
                  "endColumn": 60,
                  "charOffset": 11491,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq)",
                      "markdown": "`malloc(sizeof(custom_match_umq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11491,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c0bdc3bf-6fb1-34fa-82de-73dc3da1e0b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 15,
                  "endLine": 418,
                  "endColumn": 51,
                  "charOffset": 10762,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq_node)",
                      "markdown": "`malloc(sizeof(custom_match_umq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10762,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2ac6931a-0eca-3404-abc8-060a2a8967ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 15,
                  "endLine": 187,
                  "endColumn": 51,
                  "charOffset": 4805,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq_node)",
                      "markdown": "`malloc(sizeof(custom_match_prq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4805,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "05d5468d-cd8c-3a46-95af-5a7e30e2f7ee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 29,
                  "endLine": 223,
                  "endColumn": 60,
                  "charOffset": 5552,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq)",
                      "markdown": "`malloc(sizeof(custom_match_prq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5552,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "18a2966d-3ac5-32ea-b58d-041aa3f5e974",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 29,
                  "endLine": 519,
                  "endColumn": 60,
                  "charOffset": 14672,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq)",
                      "markdown": "`malloc(sizeof(custom_match_umq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14672,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa0da565-8353-3a7b-a56a-0db467db118e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 479,
                  "startColumn": 19,
                  "endLine": 479,
                  "endColumn": 55,
                  "charOffset": 13676,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq_node)",
                      "markdown": "`malloc(sizeof(custom_match_umq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13676,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "79cbefea-e49d-3b47-9f32-43371426a25d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 217,
                  "startColumn": 19,
                  "endLine": 217,
                  "endColumn": 55,
                  "charOffset": 6477,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq_node)",
                      "markdown": "`malloc(sizeof(custom_match_prq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6477,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6377e878-8009-3d0d-8f66-3d682ef4bb7a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 29,
                  "endLine": 266,
                  "endColumn": 60,
                  "charOffset": 7724,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq)",
                      "markdown": "`malloc(sizeof(custom_match_prq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7724,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "09701811-c9dd-3480-b2ec-91d4d73f6e53",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 336,
                  "startColumn": 17,
                  "endLine": 336,
                  "endColumn": 28,
                  "charOffset": 9356,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9356,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9356,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4419b943-13ca-376e-b726-65bd7f1d1a06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 332,
                  "startColumn": 55,
                  "endLine": 332,
                  "endColumn": 66,
                  "charOffset": 9276,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9276,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9276,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2a3f7eaa-854b-3e1d-83a0-1ae48674cc0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 8,
                  "endLine": 329,
                  "endColumn": 35,
                  "charOffset": 9091,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(OSHMEM_RELEASE_DATE)",
                    "rendered": {
                      "text": "strlen(OSHMEM_RELEASE_DATE)",
                      "markdown": "`strlen(OSHMEM_RELEASE_DATE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9091,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(OSHMEM_RELEASE_DATE, <size of OSHMEM_RELEASE_DATE>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9091,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(OSHMEM_RELEASE_DATE, <size of OSHMEM_RELEASE_DATE>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "fabd22dd-0f46-3a8a-8174-a1e643f61b13",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 331,
                  "startColumn": 20,
                  "endLine": 331,
                  "endColumn": 31,
                  "charOffset": 9208,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9208,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9208,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "48bb2fae-0c81-380f-9607-91c504e32c97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 55,
                  "endLine": 325,
                  "endColumn": 66,
                  "charOffset": 9040,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9040,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9040,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a8fbf458-774e-3392-ad75-8f2429750ba4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 318,
                  "startColumn": 55,
                  "endLine": 318,
                  "endColumn": 66,
                  "charOffset": 8795,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8795,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8795,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "32d6ef63-79d1-340d-8aca-2fbca7da2f6f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 20,
                  "endLine": 317,
                  "endColumn": 31,
                  "charOffset": 8727,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8727,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8727,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "19c3cbc7-f86e-3c6f-bee6-4832df848e04",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 324,
                  "startColumn": 20,
                  "endLine": 324,
                  "endColumn": 31,
                  "charOffset": 8972,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8972,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8972,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c6867226-126c-3bdd-8e41-5b180d665822",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 55,
                  "endLine": 311,
                  "endColumn": 66,
                  "charOffset": 8552,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8552,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8552,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "eb3e21d5-bc8b-3576-be80-7af14a8d88c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 310,
                  "startColumn": 20,
                  "endLine": 310,
                  "endColumn": 31,
                  "charOffset": 8484,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8484,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8484,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "052e7ef5-c407-3229-82de-4daf3372d450",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 55,
                  "endLine": 304,
                  "endColumn": 66,
                  "charOffset": 8307,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8307,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8307,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3b9a50a0-f300-3389-b46f-b9f2df3f8235",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 303,
                  "startColumn": 20,
                  "endLine": 303,
                  "endColumn": 31,
                  "charOffset": 8239,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8239,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8239,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7266bb1f-1d98-3057-8a61-524129fc51ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 8,
                  "endLine": 315,
                  "endColumn": 35,
                  "charOffset": 8603,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(OSHMEM_IDENT_STRING)",
                    "rendered": {
                      "text": "strlen(OSHMEM_IDENT_STRING)",
                      "markdown": "`strlen(OSHMEM_IDENT_STRING)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8603,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(OSHMEM_IDENT_STRING, <size of OSHMEM_IDENT_STRING>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8603,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(OSHMEM_IDENT_STRING, <size of OSHMEM_IDENT_STRING>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3e913550-e3d0-3f87-8c4d-5dd84c3fc18b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 322,
                  "startColumn": 8,
                  "endLine": 322,
                  "endColumn": 31,
                  "charOffset": 8853,
                  "charLength": 23,
                  "snippet": {
                    "text": "strlen(OSHMEM_REPO_REV)",
                    "rendered": {
                      "text": "strlen(OSHMEM_REPO_REV)",
                      "markdown": "`strlen(OSHMEM_REPO_REV)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8853,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strlen_s(OSHMEM_REPO_REV, <size of OSHMEM_REPO_REV>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8853,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strnlen(OSHMEM_REPO_REV, <size of OSHMEM_REPO_REV>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c9582433-e079-3a8d-8606-efa4b4db57d3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 308,
                  "startColumn": 8,
                  "endLine": 308,
                  "endColumn": 35,
                  "charOffset": 8358,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(OPAL_PACKAGE_STRING)",
                    "rendered": {
                      "text": "strlen(OPAL_PACKAGE_STRING)",
                      "markdown": "`strlen(OPAL_PACKAGE_STRING)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8358,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(OPAL_PACKAGE_STRING, <size of OPAL_PACKAGE_STRING>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8358,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(OPAL_PACKAGE_STRING, <size of OPAL_PACKAGE_STRING>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3fb1b2eb-7b87-3100-9917-8cae2b555994",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 298,
                  "startColumn": 11,
                  "endLine": 298,
                  "endColumn": 22,
                  "charOffset": 8071,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8071,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8071,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e98feb63-e81d-3d6f-9f8a-f1260b0873fd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 301,
                  "startColumn": 8,
                  "endLine": 301,
                  "endColumn": 36,
                  "charOffset": 8122,
                  "charLength": 28,
                  "snippet": {
                    "text": "strlen(OSHMEM_GREEK_VERSION)",
                    "rendered": {
                      "text": "strlen(OSHMEM_GREEK_VERSION)",
                      "markdown": "`strlen(OSHMEM_GREEK_VERSION)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8122,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strlen_s(OSHMEM_GREEK_VERSION, <size of OSHMEM_GREEK_VERSION>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8122,
                        "charLength": 28
                      },
                      "insertedContent": {
                        "text": "strnlen(OSHMEM_GREEK_VERSION, <size of OSHMEM_GREEK_VERSION>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8043097d-200f-3753-bfe6-8116e32977e5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 16,
                  "endLine": 299,
                  "endColumn": 27,
                  "charOffset": 8100,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(tmp)",
                    "rendered": {
                      "text": "strlen(tmp)",
                      "markdown": "`strlen(tmp)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8100,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8100,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(tmp, <size of tmp>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0322d5fa-041b-3967-ba18-4b2f40850427",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 13,
                  "endLine": 235,
                  "endColumn": 22,
                  "charOffset": 6346,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6346,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "oshmem/info/info.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6346,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cc95f32f-0f82-32cb-b719-69bf7a970032",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 26,
                  "endLine": 109,
                  "endColumn": 32,
                  "charOffset": 3059,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "241cbf32-a080-3105-8546-d104eaf9dac9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 31,
                  "endLine": 118,
                  "endColumn": 37,
                  "charOffset": 3494,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0bbe6dae-28dd-3108-9719-92e481a70721",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 24,
                  "endLine": 100,
                  "endColumn": 30,
                  "charOffset": 2771,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9153c36d-0551-38a2-a63e-843a6d3e9855",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 24,
                  "endLine": 107,
                  "endColumn": 30,
                  "charOffset": 2977,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "0b4bdfb5-50c5-37f8-b336-cc5f14ac3f40",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 84,
                  "startColumn": 24,
                  "endLine": 84,
                  "endColumn": 30,
                  "charOffset": 2177,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ebafda49-3025-39c6-a044-e770c1287bf8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "oshmem/info/info.c"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 24,
                  "endLine": 64,
                  "endColumn": 30,
                  "charOffset": 1495,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "73003818-f60a-3e31-912d-4313942d3070",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 979,
                  "startColumn": 9,
                  "endLine": 979,
                  "endColumn": 44,
                  "charOffset": 29181,
                  "charLength": 35,
                  "snippet": {
                    "text": "strcpy (error_buf, \"Unknown error\")",
                    "rendered": {
                      "text": "strcpy (error_buf, \"Unknown error\")",
                      "markdown": "`strcpy (error_buf, \"Unknown error\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29181,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error_buf, <size of error_buf>,  \"Unknown error\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29181,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strlcpy(error_buf,  \"Unknown error\", <size of error_buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f35c391-2324-3eb3-b83b-93953d477ef5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 977,
                  "startColumn": 9,
                  "endLine": 977,
                  "endColumn": 34,
                  "charOffset": 29134,
                  "charLength": 25,
                  "snippet": {
                    "text": "strcpy (error_buf, error)",
                    "rendered": {
                      "text": "strcpy (error_buf, error)",
                      "markdown": "`strcpy (error_buf, error)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29134,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error_buf, <size of error_buf>,  error)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29134,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlcpy(error_buf,  error, <size of error_buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ac73c548-2b6b-3575-838e-8f06d9602944",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 964,
                  "startColumn": 3,
                  "endLine": 964,
                  "endColumn": 46,
                  "charOffset": 28906,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy (error, \"Memory allocation failure\")",
                    "rendered": {
                      "text": "strcpy (error, \"Memory allocation failure\")",
                      "markdown": "`strcpy (error, \"Memory allocation failure\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28906,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error, <size of error>,  \"Memory allocation failure\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28906,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(error,  \"Memory allocation failure\", <size of error>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "69ad8698-efb1-3cec-909d-5a1ce46d644c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 3,
                  "endLine": 283,
                  "endColumn": 60,
                  "charOffset": 7782,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy (&state.settings, settings, sizeof (json_settings)",
                    "rendered": {
                      "text": "memcpy (&state.settings, settings, sizeof (json_settings)",
                      "markdown": "`memcpy (&state.settings, settings, sizeof (json_settings)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7782,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&state.settings, <size of &state.settings>,  settings,  sizeof (json_settings)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f5ea93f0-e1e1-3830-8c9e-3563b70eab6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 12,
                  "endLine": 120,
                  "endColumn": 38,
                  "charOffset": 3773,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(base, *source, len)",
                    "rendered": {
                      "text": "memcpy(base, *source, len)",
                      "markdown": "`memcpy(base, *source, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3773,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(base, <size of base>,  *source,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "04388287-058b-3db8-b7a0-9c761950935d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 36,
                  "endLine": 109,
                  "endColumn": 49,
                  "charOffset": 3350,
                  "charLength": 13,
                  "snippet": {
                    "text": "malloc (size)",
                    "rendered": {
                      "text": "malloc (size)",
                      "markdown": "`malloc (size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3350,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d68713bf-4373-3d89-a9ec-dd866e2c3572",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 12,
                  "endLine": 103,
                  "endColumn": 36,
                  "charOffset": 3251,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(*dest, base, len)",
                    "rendered": {
                      "text": "memcpy(*dest, base, len)",
                      "markdown": "`memcpy(*dest, base, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3251,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*dest, <size of *dest>,  base,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "391c6c2f-b32e-3b4c-8180-8853e1125f0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 21,
                  "endLine": 69,
                  "endColumn": 33,
                  "charOffset": 3216,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3216,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9a64283f-4b0a-36b3-af3d-e229000f8cb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/bigcount.h"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 26,
                  "endLine": 20,
                  "endColumn": 51,
                  "charOffset": 471,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc(sizeof(*tmp_array)",
                    "rendered": {
                      "text": "malloc(sizeof(*tmp_array)",
                      "markdown": "`malloc(sizeof(*tmp_array)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/bigcount.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 471,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4d7a9e8e-fe49-35d8-ac21-0f42d127b4b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 21,
                  "endLine": 52,
                  "endColumn": 33,
                  "charOffset": 2089,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2089,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6cfabbbe-c533-3242-8dd0-5110ce9c1e1f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                },
                "region": {
                  "startLine": 457,
                  "startColumn": 8,
                  "endLine": 457,
                  "endColumn": 15,
                  "charOffset": 13785,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ccd0dfeb-9b69-33a2-885e-c65a1455afaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                },
                "region": {
                  "startLine": 456,
                  "startColumn": 22,
                  "endLine": 456,
                  "endColumn": 33,
                  "charOffset": 13764,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(ptr)",
                    "rendered": {
                      "text": "strlen(ptr)",
                      "markdown": "`strlen(ptr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13764,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(ptr, <size of ptr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13764,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(ptr, <size of ptr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "deb3cc19-78b0-3a65-a972-d07e305df24b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 60,
                  "endLine": 689,
                  "endColumn": 85,
                  "charOffset": 23963,
                  "charLength": 25,
                  "snippet": {
                    "text": "strlen(distances[i].uuid)",
                    "rendered": {
                      "text": "strlen(distances[i].uuid)",
                      "markdown": "`strlen(distances[i].uuid)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23963,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlen_s(distances[i].uuid, <size of distances[i].uuid>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23963,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strnlen(distances[i].uuid, <size of distances[i].uuid>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c43e63f-701d-3bd3-92e3-1135a4b4e791",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 44,
                  "endLine": 277,
                  "endColumn": 59,
                  "charOffset": 8455,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(list[i])",
                    "rendered": {
                      "text": "strlen(list[i])",
                      "markdown": "`strlen(list[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8455,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(list[i], <size of list[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8455,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(list[i], <size of list[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4ce55ee2-c447-35c3-85ab-074f1fbc43e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 10,
                  "endLine": 111,
                  "endColumn": 23,
                  "charOffset": 4877,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(input)",
                    "rendered": {
                      "text": "strlen(input)",
                      "markdown": "`strlen(input)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4877,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4877,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e0159aef-10e2-3382-825b-92badd0d4b79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 79,
                  "endLine": 295,
                  "endColumn": 91,
                  "charOffset": 8908,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(name)",
                    "rendered": {
                      "text": "strlen(name)",
                      "markdown": "`strlen(name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8908,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8908,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "74c48fc3-ccec-3968-8bae-b5f2a29dec11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 29,
                  "endLine": 107,
                  "endColumn": 44,
                  "charOffset": 4833,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(destdir)",
                    "rendered": {
                      "text": "strlen(destdir)",
                      "markdown": "`strlen(destdir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4833,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4833,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "df25b02b-891e-3cda-a2b8-5d77c9ec4fec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 31,
                  "endLine": 106,
                  "endColumn": 46,
                  "charOffset": 4781,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(destdir)",
                    "rendered": {
                      "text": "strlen(destdir)",
                      "markdown": "`strlen(destdir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4781,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4781,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1b9df3e9-0b5d-3f22-8147-7003b91e3b9c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 34,
                  "endLine": 44,
                  "endColumn": 61,
                  "charOffset": 2307,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(\"@{\" #fieldname \"}\")",
                    "rendered": {
                      "text": "strlen(\"@{\" #fieldname \"}\")",
                      "markdown": "`strlen(\"@{\" #fieldname \"}\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2307,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"@{\" #fieldname \"}\", <size of \"@{\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2307,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(\"@{\" #fieldname \"}\", <size of \"@{\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "75414095-8db6-3dff-ba1a-e7d2a0f87128",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 4,
                  "endLine": 107,
                  "endColumn": 11,
                  "charOffset": 6088,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dd4f8618-b241-32fc-abb7-e755939860fe",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 18,
                  "endLine": 105,
                  "endColumn": 24,
                  "charOffset": 4726,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44190b36-699f-3917-910f-4ee3174d05db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 4,
                  "endLine": 106,
                  "endColumn": 11,
                  "charOffset": 6014,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}