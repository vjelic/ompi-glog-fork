{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "a520bc12-21e7-355b-8488-c47dd905f358",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without any check for a NULL return value. This pattern is dangerous because if malloc fails (e.g., due to memory exhaustion), it returns NULL, and dereferencing this pointer will cause undefined behavior, typically a segmentation fault. There is no evidence of a null guard before the first use, and the first use is a pointer field access, which is considered a dangerous operation. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making the risk assessment more conservative. The pointer is returned and passed to another call, but this does not mitigate the immediate risk of dereferencing a potentially NULL pointer.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the allocated memory. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nlist->next = NULL;\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or clean up\n    return NULL;\n}\nlist->next = NULL;\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, preventing undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "c0bdc3bf-6fb1-34fa-82de-73dc3da1e0b3",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of malloc is assigned to 'elem' and is used as a pointer-field dereference without a preceding null check. There is no evidence of a guard that checks whether the allocation succeeded before the pointer is dereferenced or used. This pattern can lead to a null pointer dereference if malloc fails and returns NULL, which is a genuine risk in C/C++ code. The absence of a zero guard, overflow guard, or null guard before use, combined with a dangerous first use (pointer field access), increases the likelihood that this is a real vulnerability. The pointer is also stored in a field and passed to another call, but these do not mitigate the risk of immediate null dereference.\n\n## In Context Remediation\nTo prevent a null pointer dereference after a failed memory allocation, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nelem->next = ...; // unsafe if malloc failed\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nif (elem == NULL) {\n    // Handle allocation failure, e.g., return an error or clean up\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "05d5468d-cd8c-3a46-95af-5a7e30e2f7ee",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without a preceding check for NULL. There is no zero guard or overflow guard present, and the first use is a potentially dangerous dereference (ptr-field) with no null guard before use. The pointer is also returned and passed to another call, increasing the risk of propagating a NULL pointer. These factors indicate a genuine risk of null pointer dereference if malloc fails, which can lead to undefined behavior or crashes. The absence of a cast does not mitigate the risk. The classification and call verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nlist->next = NULL; // unsafe if malloc fails\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or clean up\n    return NULL;\n}\nlist->next = NULL; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "2ac6931a-0eca-3404-abc8-060a2a8967ef",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of malloc is assigned to 'elem' and is used as a pointer-field dereference without a preceding null check. There is no evidence of a guard that checks whether the allocation succeeded before the pointer is dereferenced or used. This pattern can lead to a null pointer dereference if malloc fails and returns NULL, which is a well-known source of runtime errors and potential security vulnerabilities. The absence of zero guards, overflow guards, and null checks, combined with the immediate use of the allocated pointer, increases the risk of a genuine vulnerability. The classification and call verdict both indicate a high-confidence, actionable issue.\n\n## In Context Remediation\nAlways check the result of malloc before using the allocated pointer. If malloc returns NULL, handle the error appropriately (e.g., by returning an error code, logging, or cleaning up). For example, if your original code is:\n\n```c\ncustom_match_prq_node *elem = malloc(sizeof(custom_match_prq_node));\nelem->next = ...; // unsafe if elem is NULL\n```\n\nA safe version would be:\n\n```c\ncustom_match_prq_node *elem = malloc(sizeof(custom_match_prq_node));\nif (elem == NULL) {\n    // Handle allocation failure: log, cleanup, or return error\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use\n```\n\nThis ensures that the pointer is only dereferenced if the allocation succeeded, preventing null pointer dereference vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "18a2966d-3ac5-32ea-b58d-041aa3f5e974",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The first use of the allocated pointer is a potentially dangerous operation (ptr-field) and there is no null guard before this use. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making it harder to reason about safety. The pointer is returned and passed to another call, but these do not mitigate the risk of a null dereference. The call verdict is 'GENUINE', confirming this is a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after a failed malloc, always check the result of malloc before using the allocated pointer. For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nlist->field = ...; // unsafe if malloc fails\n```\n\nYou should add a null check immediately after the allocation:\n\n```c\nlist = malloc(sizeof(custom_match_umq));\nif (list == NULL) {\n    // Handle allocation failure, e.g., return error or cleanup\n    return NULL;\n}\nlist->field = ...; // safe to use\n```\n\nThis ensures that if malloc fails and returns NULL, the code does not attempt to dereference a null pointer, which would cause undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "aa0da565-8353-3a7b-a56a-0db467db118e",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The absence of a null guard before the first use of the allocated pointer increases the risk of a null dereference if memory allocation fails. The first use is a potentially dangerous pointer field access, and there are no zero guards or overflow guards present. The pointer is also stored in a field and passed to another call, which can propagate the risk. These factors indicate a genuine vulnerability, specifically a possible null pointer dereference after a failed memory allocation.\n\n## In Context Remediation\nAlways check the result of malloc for NULL before using the allocated pointer. If malloc fails, handle the error appropriately (e.g., return an error code, log the failure, or clean up resources). For example, if your original code is:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nelem->next = ...; // unsafe if elem is NULL\n```\n\nA safe remediation would be:\n\n```c\ncustom_match_umq_node *elem = malloc(sizeof(custom_match_umq_node));\nif (elem == NULL) {\n    // Handle allocation failure (e.g., return error, log, etc.)\n    return ERROR_CODE;\n}\nelem->next = ...; // safe to use elem\n```\n\nThis ensures that the pointer is only dereferenced if the allocation succeeded, preventing a possible null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "6377e878-8009-3d0d-8f66-3d682ef4bb7a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used via pointer field access immediately after allocation, without any check for a NULL return value. This is a common source of null pointer dereference vulnerabilities, especially if malloc fails and returns NULL. There is no evidence of a guard (such as an if-statement) checking whether the allocation succeeded before the pointer is dereferenced. The first use is a potentially dangerous pointer field access, and no null guard is present before this use. The function returns the pointer and also passes it to another call, which increases the risk if the allocation fails. These factors indicate a genuine vulnerability with a low probability of being a false positive.\n\n## In Context Remediation\nAlways check the result of malloc before using the allocated pointer. If malloc returns NULL, handle the error appropriately (e.g., return an error code, log the failure, or clean up resources). For example, if your original code is:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nlist->field = ...; // unsafe: possible null dereference\n```\n\nA safe version would be:\n\n```c\nlist = malloc(sizeof(custom_match_prq));\nif (list == NULL) {\n    // Handle allocation failure (e.g., return NULL, log error, etc.)\n    return NULL;\n}\nlist->field = ...; // safe: list is guaranteed non-null\n```\n\nThis ensures that the pointer is not dereferenced if the allocation fails, preventing undefined behavior and potential security vulnerabilities.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "79cbefea-e49d-3b47-9f32-43371426a25d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of a malloc call is used (via pointer field access) without a preceding check for NULL. The absence of a null guard before the first use of the allocated pointer increases the risk of a null pointer dereference if memory allocation fails. The first use is a pointer field access, which is considered dangerous if the pointer is not validated. No zero guard or overflow guard is present, and the allocation size is not a simple sizeof(T) pattern, making the allocation less obviously safe. The pointer is also stored in a field and passed to another call, but these do not mitigate the risk of dereferencing a null pointer. The call verdict is 'GENUINE', confirming this is a real issue.\n\n## In Context Remediation\nTo prevent a null pointer dereference after memory allocation, always check the result of malloc before using the allocated pointer. For example, after:\n\n```c\nelem = malloc(sizeof(custom_match_prq_node));\n```\nadd a null check before using `elem`:\n\n```c\nif (elem == NULL) {\n    // Handle allocation failure, e.g., return an error or clean up\n    return ERROR_CODE;\n}\n```\nThis ensures that if malloc fails and returns NULL, the code does not attempt to access fields or use the pointer, preventing undefined behavior or crashes.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "73003818-f60a-3e31-912d-4313942d3070",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strcpy` and instead use safer alternatives that check the size of the destination buffer. These include functions like `strncpy`, `strlcpy`, or `memcpy`. However, these functions also have their own caveats and must be used correctly to avoid vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(error_buf, \"Unknown error\", sizeof(error_buf) - 1);\nerror_buf[sizeof(error_buf) - 1] = '\\0';\n```\n\nThis code will copy the string \"Unknown error\" into `error_buf`, but it will not exceed the size of `error_buf`. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "6f35c391-2324-3eb3-b83b-93953d477ef5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is used to copy the content of one string to another. However, it is considered a dangerous function as it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter, such as `strncpy`, `strlcpy`, or `memcpy`. These functions allow you to specify the maximum number of characters to be copied, preventing buffer overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with `strncpy`:\n\n```cpp\nstrncpy(error_buf, error, sizeof(error_buf));\nerror_buf[sizeof(error_buf) - 1] = '\\0'; // Ensure null-termination\n```\n\nThis code will copy at most `sizeof(error_buf)` characters from `error` to `error_buf`, and ensures that `error_buf` is null-terminated.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "ac73c548-2b6b-3575-838e-8f06d9602944",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to crashes, data corruption, and potentially code execution, making it a serious security risk.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using `strcpy` and instead use safer alternatives that check the size of the destination buffer. These include functions like `strncpy`, `strlcpy`, or `memcpy`. However, these functions also have their own caveats and must be used correctly to avoid vulnerabilities.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy`:\n\n```cpp\nstrncpy(error, \"Memory allocation failure\", sizeof(error) - 1);\nerror[sizeof(error) - 1] = '\\0';\n```\n\nThis code will copy the string to the `error` buffer, but it will not exceed the size of the buffer. The `- 1` is to leave space for the null terminator, which is then manually added on the next line.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "04388287-058b-3db8-b7a0-9c761950935d",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'High Risk' because the calloc call uses a product expression for the allocation size (nmemb * size), but there are no zero guards or overflow guards present. This can lead to integer overflow, resulting in a buffer that is smaller than intended, which is a well-known security vulnerability. The absence of a left-hand side variable (lhsVar) suggests the result may not be used, but the risk remains due to the unchecked multiplication. The call verdict is 'GENUINE', confirming this is a real issue. No mitigating factors such as guards or safe types are present.\n\n## In Context Remediation\nTo prevent integer overflow in the allocation size calculation, always check that the multiplication of the number of elements and the size of each element does not exceed the maximum value representable by size_t. You can do this by adding an explicit check before the calloc call:\n\n```c\nif (size != 0 && SIZE_MAX / size < 1) {\n    // Handle overflow error, e.g., return NULL or set an error code\n} else {\n    void *ptr = calloc(1, size);\n    // Use ptr safely\n}\n```\nThis ensures that the multiplication will not wrap around and cause a buffer smaller than intended to be allocated, which could lead to buffer overflows or other memory safety issues.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "69ad8698-efb1-3cec-909d-5a1ce46d644c",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a 'UB Risk' (undefined behavior risk) due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may overlap based on data flow, which can lead to undefined behavior when using functions like memcpy. Additionally, there is a risk that the source pointer may be null, as there is no prior check ensuring it is valid. The destination is not likely to be null, but the overlap and null source risks make this a high-confidence, actionable issue. No evidence suggests that the operation is safe by construction or intentionally guarded.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. Additionally, ensure that the source pointer is not null before performing the copy operation. For example:\n\n```c\nif (settings != NULL) {\n    memmove(&state.settings, settings, sizeof(json_settings));\n}\n```\nThis change ensures that the copy is safe even if the source and destination overlap, and avoids dereferencing a null pointer.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-416: Use After Free](https://cwe.mitre.org/data/definitions/416.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "f5ea93f0-e1e1-3830-8c9e-3563b70eab6e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions. The analysis detected that the source and destination may refer to overlapping memory through data flow analysis. Additionally, the verdict for this call site is marked as 'GENUINE', which further confirms the risk. The source pointer may also be null at this location, increasing the risk of undefined behavior. There are no explicit checks or guards to prevent these issues, and the destination buffer's size is not clearly defined or enforced. The use of memcpy in this context is unsafe if the source and destination overlap, as memcpy does not guarantee correct behavior in such cases.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the use of `memcpy` with `memmove`, which is designed to handle overlapping memory safely. For example, change the code to:\n\n```c\nmemmove(base, *source, len);\n```\n\nThis ensures that the copy operation is performed correctly even if the source and destination regions overlap. Additionally, consider adding checks to ensure that the source pointer is not null before performing the copy to avoid null pointer dereference.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-124: Buffer Underwrite ('Buffer Underflow')](https://cwe.mitre.org/data/definitions/124.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "d68713bf-4373-3d89-a9ec-dd866e2c3572",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source may refer to overlapping memory, as indicated by the dataflow analysis. Additionally, there is no evidence of a guard to prevent this overlap, and the source pointer may also be null, which could lead to a crash or further undefined behavior. The function does not use a standard or safe pattern for determining the size of the destination buffer, and the length argument is not derived from the destination's capacity. These factors all contribute to a high confidence that this is a real and actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination memory regions do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, check that the source pointer is not null before performing the copy to avoid a potential crash.\n\n**Remediation Example:**\n\n```c\nif (base != NULL && *dest != NULL) {\n    memmove(*dest, base, len); // memmove is safe for overlapping regions\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly and add runtime assertions to enforce it:\n\n```c\nassert(base != *dest); // or a more precise check for overlap\nmemcpy(*dest, base, len);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "391c6c2f-b32e-3b4c-8180-8853e1125f0f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(size)` function in C++ is used to dynamically allocate a block of memory on the heap. The size of the block is specified by the `size` parameter. If the allocation is successful, the function returns a pointer to the beginning of the block. The memory allocated by `malloc` is uninitialized and can contain any data.\n\nA vulnerability can occur when the `size` parameter passed to `malloc` is not properly validated or controlled. This can lead to several types of vulnerabilities, including buffer overflows, integer overflows, and memory corruption. These vulnerabilities can be exploited to execute arbitrary code, cause a denial of service, or leak sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n- Always validate and limit the `size` parameter passed to `malloc`.\n- Check the return value of `malloc` to ensure that the allocation was successful.\n- Initialize the allocated memory to a known value using `memset` or similar function.\n- Use a safe version of `malloc` that includes built-in error checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to safely use `malloc`:\n\n```cpp\n#include <stdlib.h>\n#include <string.h>\n\nvoid* safe_malloc(size_t size) {\n    if (size == 0 || size > SIZE_MAX) {\n        // Invalid size\n        return NULL;\n    }\n\n    void* ptr = malloc(size);\n    if (ptr == NULL) {\n        // Allocation failed\n        return NULL;\n    }\n\n    // Initialize memory to zero\n    memset(ptr, 0, size);\n\n    return ptr;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `malloc`\n- `string.h`: for `memset`\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "4d7a9e8e-fe49-35d8-ac21-0f42d127b4b6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(size)` function in C++ is used to dynamically allocate a block of memory on the heap. The size of the block is specified by the `size` parameter. If the allocation is successful, the function returns a pointer to the beginning of the block. The memory allocated by `malloc` is uninitialized and can contain any data.\n\nA vulnerability can occur when the `size` parameter passed to `malloc` is not properly validated or controlled. This can lead to several types of vulnerabilities, including buffer overflows, integer overflows, and memory corruption. These vulnerabilities can be exploited to execute arbitrary code, cause a denial of service, or leak sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n- Always validate and limit the `size` parameter passed to `malloc`.\n- Check the return value of `malloc` to ensure that the allocation was successful.\n- Initialize the allocated memory to a known value using `memset` or similar function.\n- Use a safe version of `malloc` that includes built-in error checking and validation.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to safely use `malloc`:\n\n```cpp\n#include <stdlib.h>\n#include <string.h>\n\nvoid* safe_malloc(size_t size) {\n    if (size == 0 || size > SIZE_MAX) {\n        // Invalid size\n        return NULL;\n    }\n\n    void* ptr = malloc(size);\n    if (ptr == NULL) {\n        // Allocation failed\n        return NULL;\n    }\n\n    // Initialize memory to zero\n    memset(ptr, 0, size);\n\n    return ptr;\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for `malloc`\n- `string.h`: for `memset`\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "ccd0dfeb-9b69-33a2-885e-c65a1455afaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using safer alternatives that take the size of the buffer as an argument, such as `strnlen`, which will not read past the specified length.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nread_offset = strlen(ptr);\n```\n\nYou could use:\n\n```cpp\nread_offset = strnlen(ptr, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen` from reading past the end of the buffer.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "6cfabbbe-c533-3242-8dd0-5110ce9c1e1f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, format string vulnerabilities, or other types of memory corruption. In this case, the function in question is `memmove()`. This function is used to copy a block of memory from one location to another and it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that include bounds checking to prevent buffer overflow. In C++, this could be achieved by using standard library functions or classes that automatically manage memory, such as `std::vector` or `std::string`.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove()` function with a safer alternative. For example, if `buffer` and `ptr` are arrays or vectors of a certain type, you could use `std::copy()` from the `<algorithm>` library, which checks the bounds of the destination:\n\n```cpp\n#include <algorithm>\n\n// Assuming buffer and ptr are of type std::vector<char> or similar\nstd::copy(ptr, ptr + read_offset, buffer.begin());\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `memmove()` function.\n\n## OWASP and CWE Links\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9a64283f-4b0a-36b3-af3d-e229000f8cb0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used correctly. If the size argument passed to `malloc` is not properly validated or calculated, it can lead to buffer overflow, integer overflow, or other memory corruption issues. This can potentially allow an attacker to execute arbitrary code or cause a Denial of Service (DoS) condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize the size argument passed to `malloc`.\n2. Use functions that limit the amount of memory allocated, such as `calloc`.\n3. Consider using modern C++ features like smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory and help prevent memory leaks and other issues.\n4. Regularly use static code analysis tools to detect potential vulnerabilities.\n\n## Source Code Fix Recommendation\n\nIf `tmp_array` is an array of integers, the code could be fixed as follows:\n\n```cpp\n// Check if the size is valid\nif (size <= 0) {\n    // Handle error\n}\n\n// Allocate memory\ntmp_array = (int*) malloc(size * sizeof(int));\n\n// Check if memory allocation was successful\nif (tmp_array == NULL) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc` function is part of the C Standard Library (`stdlib.h` or `cstdlib` in C++).\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "deb3cc19-78b0-3a65-a972-d07e305df24b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string, but it can lead to buffer overflow vulnerabilities if not used properly. In the provided code snippet, the `strlen` function is used without checking if the string is null-terminated. If the string is not null-terminated, `strlen` will continue reading until it finds a null character, potentially reading past the end of the buffer and causing a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (!addr || addr + 3 > distances[i].uuid + (distances[i].uuid ? strnlen(distances[i].uuid, MAX_UUID_LENGTH) : 0))\n```\n\nIn this fix, `strnlen` is used instead of `strlen`, and a maximum length `MAX_UUID_LENGTH` is provided to prevent reading past the end of the buffer. Additionally, a check is added to ensure `distances[i].uuid` is not null before calling `strnlen`.\n\n## Library Dependencies\n\nThe code snippet does not appear to require any specific library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "e0159aef-10e2-3382-825b-92badd0d4b79",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in this code snippet is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it does not check for null termination. This can lead to buffer overflows if the string is not properly null-terminated, which can lead to crashes, data corruption, and potential security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include bounds checking, such as `strnlen` or `strncpy`. These functions will prevent buffer overflows by ensuring that the string does not exceed a specified length.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code snippet:\n\n```cpp\nprev_prov && !strncasecmp(prev_prov->fabric_attr->prov_name, name, strnlen(name, MAX_NAME_LENGTH))\n```\n\nIn this fix, `strnlen` is used instead of `strlen`. `MAX_NAME_LENGTH` is a predefined constant that specifies the maximum length of the string `name`.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `string.h`: This library is required for the `strncasecmp` and `strlen` functions.\n- `fi_prov.h`: This library is assumed to be required for the `prev_prov->fabric_attr->prov_name` object.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4c43e63f-701d-3bd3-92e3-1135a4b4e791",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the use of the `strlen` function in C++. The `strlen` function is used to determine the length of a string, but it can lead to buffer overflow vulnerabilities if not used carefully. In the provided code snippet, `strlen(list[i])` is used as the maximum number of characters to compare in the `strncasecmp` function. If `list[i]` is shorter than `item`, this can lead to reading beyond the end of `list[i]`, which is undefined behavior and can potentially be exploited.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that you are not reading beyond the end of the string. This can be done by comparing the lengths of the strings before using them in the `strncasecmp` function. If `item` is longer than `list[i]`, you should not proceed with the comparison.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the vulnerability:\n\n```cpp\nif (strlen(item) >= strlen(list[i])) {\n    if (0 == strncasecmp(item, list[i], strlen(list[i]))) {\n        // ...\n    }\n}\n```\n\nIn this code, we first check if `item` is longer than or equal to `list[i]`. If it is, we proceed with the `strncasecmp` comparison. This ensures that we are not reading beyond the end of `list[i]`.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`: This library is required for the `strlen` and `strncasecmp` functions.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "df25b02b-891e-3cda-a2b8-5d77c9ec4fec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen` function in C++. The `strlen` function is used to find the length of a string. However, it can lead to a vulnerability if the string is not null-terminated or if the string is `NULL`. In the provided code snippet, `strlen(destdir)` is called without checking if `destdir` is `NULL` or not. If `destdir` is `NULL`, the `strlen` function will cause a segmentation fault, leading to a crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the string passed to `strlen` is not `NULL`. This can be done by adding an additional check before calling `strlen`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (NULL != destdir) {\n    if (destdir[0] != '\\0') {\n        // rest of the code\n    }\n}\n```\n\nIn this fixed code, we first check if `destdir` is not `NULL`. Then, we check if the first character of `destdir` is not the null character (`'\\0'`). This ensures that `destdir` is not `NULL` and is not an empty string.\n\n## Library Dependencies\n\nThe code example requires the `cstring` library for the `strlen` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "4ce55ee2-c447-35c3-85ab-074f1fbc43e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when handling user input or data from untrusted sources. Consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nlen = strlen(input);\n```\n\nYou could use:\n\n```c++\nlen = strnlen(input, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of your string. This ensures that `strnlen` will not read past `MAX_LEN` characters, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so you need to include the `cstring` header:\n\n```c++\n#include <cstring>\n```\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "74c48fc3-ccec-3968-8bae-b5f2a29dec11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your string. Additionally, consider using safer alternatives to `strlen` such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\ndestdir_offset = strlen(destdir);\n```\n\nConsider using:\n\n```cpp\ndestdir_offset = strnlen(destdir, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of `destdir`. This ensures that `strnlen` will not read past `MAX_LENGTH`, even if it does not encounter a null character.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "0d9aa21e-d20f-32fb-8675-7efa9aec838e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Found\" vulnerability in C++ refers to the use of certain C library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the `sscanf` function is used, which can lead to buffer overflow vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `sscanf`, consider using `strncpy` or `snprintf` which allow you to specify the maximum number of characters to be copied, thus preventing buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code:\n\n```cpp\nchar rsc_tl_name[SIZE];\nchar rsc_device_name[SIZE];\n\n// Ensure that the format string specifies the maximum buffer size\nret = sscanf(line, \"%*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %*s %"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b93671c9-16dd-3436-9638-adea641cdb2d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure or unsafe C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `strerror()` is used which is not thread-safe and can lead to race conditions if used in a multi-threaded environment.\n\n## Mitigation Advice\n\nAvoid using non-reentrant functions like `strerror()`. Instead, use thread-safe alternatives like `strerror_r()`. Also, consider using higher-level abstractions provided by the C++ Standard Library, which are usually safer and less prone to error.\n\n## Source Code Fix Recommendation\n\nReplace the `strerror()` function with `strerror_r()`:\n\n```cpp\nchar buf[1024];\nstrerror_r(errno, buf, sizeof(buf));\nMCA_COMMON_UCX_VERBOSE(2, \"readlink(%s) failed: %s\", sysfs_driver_link, buf);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `errno.h`: for `errno`\n- `string.h`: for `strerror()`\n- `stdio.h`: for `printf()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fe5b4ff2-9433-3d4a-a3ec-9fd71a44cb25",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `sscanf` function is used, which can lead to buffer overflow vulnerabilities if not used carefully.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `sscanf`, you can use `std::istringstream` along with `std::getline` or `std::regex` for parsing strings.\n\n## Source Code Fix Recommendation\n\nHere is a safer alternative using `std::istringstream` and `std::getline`:\n\n```cpp\n#include <string>\n#include <sstream>\n\nstd::string device_name;\nstd::string ib_device_name;\nstd::istringstream iss(device_name);\nstd::getline(iss, ib_device_name, ' '); // assuming ' ' is the delimiter\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdio>` for `sscanf`\n- `<string>` for `std::string`\n- `<sstream>` for `std::istringstream`\n- `<regex>` for `std::regex` (if used)\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c6954dfa-9224-3cf7-a6ba-d58c1e581409",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1b9df3e9-0b5d-3f22-8147-7003b91e3b9c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the null-terminating character. If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other memory corruption issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen`. Additionally, consider using safer alternatives to `strlen` that take a maximum length parameter, such as `strnlen`, to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen`, use `strnlen` with a maximum length parameter:\n\n```cpp\nstrnlen(\"@{\" #fieldname \"}\", MAX_LENGTH);\n```\n\nReplace `MAX_LENGTH` with the maximum expected length of the string. This ensures that `strnlen` will not read past the end of the string, even if it is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "dd4f8618-b241-32fc-abb7-e755939860fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In the provided code snippet, the function `getenv()` is used, which can lead to security vulnerabilities. This function returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program, but can be overwritten by a subsequent call to `getenv()`, `putenv()`, `setenv()`, or `unsetenv()`.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In this case, instead of `getenv()`, consider using a method that does not allow for potential overwrites or modifications. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>\n#include <string>\n\nstd::string destdir;\nconst char* tmp = std::getenv(\"OPAL_DESTDIR\");\nif(tmp != nullptr) {\n    destdir = tmp;\n}\n```\n\nIn this code, we are still using `getenv()`, but we immediately copy the result into a `std::string`. This way, even if a subsequent call to `getenv()`, `putenv()`, `setenv()`, or `unsetenv()` overwrites the original data, our copy remains valid.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- cstdlib\n- string\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e48d881e-c650-38d5-94b8-c57e47e1e7c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"${\" #fieldname \"}\")`, the vulnerability arises if the `fieldname` is not properly sanitized or is controlled by an attacker. This could lead to a buffer overflow or other types of memory corruption.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. Additionally, avoid using `strlen` on strings that could potentially be controlled by an attacker. Instead, use safer alternatives that limit the number of characters read from the string, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and provide a maximum length for the string. This will prevent the function from reading past the end of the string if it is not null-terminated.\n\n```cpp\nstrnlen(\"${\" #fieldname \"}\", MAX_FIELDNAME_LENGTH);\n```\n\nIn this code, `MAX_FIELDNAME_LENGTH` is a constant that defines the maximum length of the `fieldname`. This value should be defined based on the specific requirements of your program.\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "75414095-8db6-3dff-ba1a-e7d2a0f87128",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "44190b36-699f-3917-910f-4ee3174d05db",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "99b61587-aa2b-38f9-b09c-2ccdc4f6b022",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "ba32caf8-80d1-3122-9d39-aa425481abb9",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a833f709-fae5-302f-8202-89043901d01c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "15df7a07-55af-3d6c-88d0-6ab67d819b78",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "037ca1bd-9e0b-3a45-ae0e-96303e7a0abf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "381b991c-4b2d-30ad-be5f-841a10cbe1f6",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2ea583ed-ed37-3f26-b5c1-e3a75cf67bbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e3284542-7cd5-3e08-afa7-a3b8739b59bc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dd4b5822-f86a-3da2-b756-df995b852f55",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e5fbd770-f8e4-307f-b19d-d44fe90cbe0f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "72641361-0773-324e-8bf2-a0d85244da2a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "fe67f9df-9613-30d0-a5cc-b60f57b16449",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "422dde12-c713-3135-b2d4-fb4593ba5d5f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "30071bea-d386-317b-ba29-bf2c5b49c076",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3d8625c1-7582-3154-a30e-ca50ca2ea4ed",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's composed dynamically, it can lead to buffer overflows if the output is larger than the buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fprintf` such as `snprintf` or `vsnprintf`. These functions include the size of the buffer as an argument, which can prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nInstead of using `fprintf`, use `snprintf` or `vsnprintf`. Here is an example:\n\n```cpp\n#include <stdio.h>\n\nvoid safe_function(const char* format, ...) {\n    char buffer[1024];\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, sizeof(buffer), format, args);\n    va_end(args);\n    // Now buffer contains the formatted string.\n    // You can write it to file with fwrite or similar\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- stdio.h\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n\n## CWE\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b815fbd1-1ea3-3366-8a52-3a98c8e82658",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The destination and source are both generic pointers, and dataflow analysis suggests that the destination may be derived from the source, which can lead to overlapping memory regions. The use of a standard memory copy function in such a scenario is unsafe, as it does not handle overlapping regions correctly. Additionally, there is no evidence of a guard to ensure that the source is non-null, which further increases the risk of undefined behavior. The absence of explicit buffer size checks or null-termination also contributes to the risk. These factors indicate a high likelihood of a real issue that could result in memory corruption or program crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the standard memory copy function with a function that safely handles overlapping regions. In C, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory areas safely. For example, change the code to:\n\n```c\nmemmove(dst, src, copy_size);\n```\n\nAdditionally, ensure that both the source and destination pointers are not null before performing the operation to avoid null pointer dereference:\n\n```c\nif (dst != NULL && src != NULL) {\n    memmove(dst, src, copy_size);\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ac3b5122-538b-36fa-bce7-6b9c72b42046",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited because they do not perform bounds checking or input validation, which can lead to vulnerabilities if not handled properly.\n\nIn the context of the provided sink `opal_process_info.nodename`, it seems like it's a part of Open MPI project. If this variable is used improperly, it might lead to a security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions that perform necessary bounds checking and input validation. For instance, instead of using `strcpy()`, use `strncpy()` which allows you to specify the maximum number of characters to be copied, thus preventing buffer overflow.\n\nAlso, always validate and sanitize inputs before processing them. Never trust user input blindly. \n\n## Source Code Fix Recommendation\n\nWithout the actual source code, it's hard to provide a specific fix. However, if `opal_process_info.nodename` is being used in an insecure function, replace that function with a safer alternative. If it's a string that's being passed to a function, ensure that the function does not exceed the bounds of the string.\n\n## Library Dependencies\n\nWithout the actual code, it's hard to list the specific library dependencies. However, in general, C++ programs might require standard libraries like `<iostream>`, `<string>`, etc. If it's using Open MPI, then it would require the Open MPI library.\n\n## OWASP and CWE Links\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that these links are subject to change and might require a subscription or membership to access certain resources."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e1de7daa-cd26-33a8-a127-015854f821da",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or other types of security issues. In the provided code, the `fopen` function is used, which can lead to potential security risks if not properly managed.\n\nThe `fopen` function is used to open a file, but it does not check for any permissions or restrictions. This can lead to unauthorized access or manipulation of files, leading to potential security breaches.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions. For instance, instead of `fopen`, you can use `fopen_s` which is a safer version of `fopen`. It's also important to always check the return value of `fopen` to ensure that the file was opened successfully.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code:\n\n```cpp\nerrno_t err;\n\nif ((err = fopen_s(&f, \"/proc/net/if_inet6\", \"r\")) != 0) {\n    // Handle error\n} else {\n    // File opened successfully\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `stdio.h`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "24474ff0-1e29-3eeb-b2fc-1745ded73b1a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is marked as 'GENUINE', and the classification explicitly states a risk of undefined behavior. The analysis determined that overlap is feasible based on data flow between the source and destination, which can cause unpredictable results with functions like memcpy. Additionally, the source may be null at this call site, which further increases the risk of a crash or undefined behavior. There are no explicit guards or null-termination after the copy, and the destination is not a pointer-based member, suggesting it is likely a local variable or struct field. These factors all indicate a real and actionable issue that should be addressed to prevent memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory safely, whereas `memcpy` is not. Replace the original call with:\n\n```c\nmemmove(&a4, &(sin_addr->sin_addr), sizeof(struct in_addr));\n```\n\nThis change ensures that the copy operation is safe even if the source and destination overlap. Always verify that both source and destination pointers are valid and not null before performing the operation.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e166c239-4613-382d-8968-3f59fe22fca3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the `memcpy` function is copying the contents of `sin_addr->sin6_addr` into `a6`. If the size of `sin_addr->sin6_addr` is larger than `a6`, it could lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination buffers before calling `memcpy`. Additionally, consider using safer functions such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(a6) >= sizeof(sin_addr->sin6_addr)) {\n    memcpy(&a6, &(sin_addr->sin6_addr), sizeof(struct in6_addr));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `a6` is larger or equal to the size of `sin_addr->sin6_addr`. If it is, we proceed with the `memcpy`. If it isn't, we handle the error appropriately.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `#include <string.h>` for `memcpy`\n- `#include <netinet/in.h>` for `struct in6_addr`\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "28d97cdc-2d97-3a00-81a9-2fd90c4e9b17",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C and C++ is used to dynamically allocate memory. The vulnerability arises when the size of the memory to be allocated is not properly validated or calculated, leading to buffer overflow, memory corruption, or other related issues. In the given code snippet, `malloc(48 * sizeof(char))`, there is no immediate vulnerability. However, if the size parameter is influenced by user input or other external factors, it could lead to vulnerabilities.\n\n## Mitigation Advice\n\n1. Always validate and sanitize the size of the memory to be allocated.\n2. Use functions that limit the amount of data written into the memory such as `strncpy` instead of `strcpy`.\n3. Consider using modern C++ features like smart pointers (`std::unique_ptr`, `std::shared_ptr`) or container classes (`std::vector`, `std::array`) that manage memory automatically.\n\n## Source Code Fix Recommendation\n\nIf the size of the memory to be allocated is influenced by user input or other external factors, validate it before using it in `malloc`. For example:\n\n```cpp\nsize_t size = get_size(); // get_size() is a hypothetical function that gets size from user or other external factors\nif (size > MAX_SIZE) {\n    // handle error\n} else {\n    char* buffer = (char*) malloc(size * sizeof(char));\n    if (buffer == NULL) {\n        // handle error\n    } else {\n        // use buffer\n        free(buffer);\n    }\n}\n```\n\nIn this code, `MAX_SIZE` is a predefined constant that represents the maximum allowable size.\n\n## Library Dependencies\n\nThe `malloc` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "73f00766-dfba-317b-a42d-eb2b3db79ccd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. The vulnerability arises when the size of the memory to be allocated is not correctly calculated, leading to buffer overflow or underflow errors. In this case, the `malloc` function is allocating memory for a pointer to `struct ifaddrs` instead of the `struct ifaddrs` itself. This can lead to insufficient memory allocation and potential buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, ensure that the correct size of the memory to be allocated is calculated. This can be done by using the `sizeof` operator on the actual data type or structure that needs to be stored, not on its pointer.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nmalloc(sizeof(struct ifaddrs *));\n```\n\nUse:\n\n```cpp\nmalloc(sizeof(struct ifaddrs));\n```\n\n## Library Dependencies\n\nThe `ifaddrs` structure is defined in the `<ifaddrs.h>` header file, which is part of the standard C library. Therefore, the only library dependency required by the code example is the standard C library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "9fd2c352-6b51-3d8b-b105-315b30c0a746",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. `malloc` is a function that dynamically allocates memory at runtime. The problem arises when the size of the memory to be allocated is not properly validated or controlled, which can lead to various security issues such as buffer overflows, memory corruption, or denial of service attacks.\n\nIn the provided code snippet, `ifconf.ifc_req = malloc(ifc_len)`, the `ifc_len` variable is used to determine the amount of memory to allocate. If `ifc_len` is not properly validated, it could lead to the aforementioned security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and control the size of the memory to be allocated.\n2. Use functions that limit the amount of memory to be allocated, such as `calloc`.\n3. Always check the return value of `malloc` to ensure that the memory allocation was successful.\n\n## Source Code Fix Recommendation\n\nA possible fix for the provided code snippet could be:\n\n```cpp\nif (ifc_len > 0 && ifc_len <= MAX_LEN) {\n    ifconf.ifc_req = (struct ifreq *)malloc(ifc_len);\n    if (ifconf.ifc_req == NULL) {\n        // Handle error\n    }\n} else {\n    // Handle error\n}\n```\n\nIn this fix, `ifc_len` is first checked to ensure it is within a valid range. Then, after the `malloc` call, the return value is checked to ensure that the memory allocation was successful.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `stdlib.h`: for the `malloc` function\n- `sys/ioctl.h`: for the `ifconf` structure\n- `net/if.h`: for the `ifreq` structure\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "f91dbecf-114f-3ee7-9c9c-c5fe7fd121e0",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. The analysis determined that the source and destination may overlap based on data flow, which can cause unpredictable results when using memory copy functions that do not support overlapping regions. Both the source and destination pointers are confirmed to be non-null before the call, so the main concern is the potential for overlapping memory, which is not handled safely by the standard memory copy function.\n\n## In Context Remediation\nTo prevent undefined behavior when there is a possibility that the source and destination memory regions may overlap, use a memory move function that is designed to handle overlapping regions. Replace the memory copy function with a memory move function, which safely handles overlapping memory:\n\n```c\nmemmove(intf->if_mac, ifr->ifr_hwaddr.sa_data, 6);\n```\n\nThis change ensures that the operation is safe even if the source and destination overlap, eliminating the risk of undefined behavior.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "1943ef41-0891-37a1-8bb5-96478ef01f57",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if not used properly. \n\nThe `fopen` function is used to open a file and returns a FILE pointer. If the specified file does not exist, or the path is incorrect, or the program does not have sufficient permissions to open the file, the function will return a NULL pointer. This can lead to null pointer dereferencing if not checked properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to use these functions in a way that their risks are mitigated. \n\nFor the `fopen` function, it is important to always check the returned pointer before using it. If the function fails, it will return a NULL pointer, and trying to use this pointer will lead to undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a safer way to use the `fopen` function:\n\n```cpp\nFILE *fh = fopen(\"/proc/self/maps\", \"r\");\nif (fh == NULL) {\n    // Handle error\n    printf(\"Error opening file\\n\");\n    return 1;\n}\n// Continue with the rest of the code\n```\n\nIn this code, we check if the `fopen` function returned a NULL pointer, and if it did, we handle the error and stop the execution of the program.\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- stdio.h\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "dfcd4818-405b-3f51-b6f1-f0d5ea0f2018",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The source and destination expressions share the same base structure, which increases the likelihood that they may refer to overlapping memory. The verdict is supported by the classification indicating undefined behavior risk and the explicit 'GENUINE' verdict. There are no explicit checks or guards in the code to prevent this overlap, and neither the source nor the destination is null at the call site, so the main concern is the potential for memory corruption or unpredictable behavior if the regions overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```c\nmemmove(reg->data.handle.accelerator, reg->gpu_reg->data.ipcHandle.handle, SMSC_ACCELERATOR_HANDLE_SIZE);\n```\n\nThis change ensures that even if the source and destination buffers overlap, the copy will be performed correctly without causing memory corruption or unpredictable behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "61b3543d-9f86-3605-8786-f1de7b37ab4a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memcpy operation. The dataflow analysis indicates that the destination and source may refer to overlapping memory, which is not allowed for memcpy and can result in unpredictable program behavior. Additionally, there is no evidence of a guard to prevent this, and the source pointer may also be null, further increasing the risk. The destination is not a pointer-based member, so it is less likely to be null, but the main concern remains the potential for overlapping memory regions. This type of issue can lead to data corruption or crashes, and should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping source and destination regions safely. Replace the original call with:\n\n```c\nmemmove(&rget_reg.data.ipcHandle.handle, reg->handle.accelerator, SMSC_ACCELERATOR_HANDLE_SIZE);\n```\n\nAdditionally, ensure that the source pointer (`reg->handle.accelerator`) is not null before performing the copy to avoid null pointer dereference:\n\n```c\nif (reg->handle.accelerator != NULL) {\n    memmove(&rget_reg.data.ipcHandle.handle, reg->handle.accelerator, SMSC_ACCELERATOR_HANDLE_SIZE);\n}\n```\n\n## References\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c875fbbb-cffc-36fd-9d93-f2fae8aa1c6a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. These functions are often prohibited in secure coding standards.\n\nThe `strerror` function is one such function. It returns a pointer to a string that describes the error code passed in the argument errno. The problem with `strerror` is that it is not thread-safe. If multiple threads call `strerror`, they might get each other's error messages.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use thread-safe alternatives to `strerror`, such as `strerror_r` or `strerror_s`. These functions take an additional argument, a buffer to hold the error message, and they return the error message in that buffer.\n\n## Source Code Fix Recommendation\n\nReplace the use of `strerror` with `strerror_r` or `strerror_s`. Here is an example of how to use `strerror_r`:\n\n```cpp\n#include <string.h>\n#include <errno.h>\n\nvoid someFunction() {\n    int errnum = errno;\n    char buf[1024];\n\n    if (strerror_r(errnum, buf, sizeof(buf)) == 0) {\n        printf(\"Error: %s\\n\", buf);\n    } else {\n        printf(\"Unknown error\\n\");\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `string.h`\n- `errno.h`\n\n## References\n\n- [OWASP C++ Secure Coding Practices Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "14d1017e-08f2-3a6a-93cc-07db1daa43bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `strlen()` function in C++. This function is used to calculate the length of a string, but it does not check for null termination. If the string is not null-terminated, `strlen()` will continue reading until it encounters a null character, potentially leading to a buffer overflow. This can cause a crash or, in the worst case, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length.\n\n## Source Code Fix Recommendation\n\nIn the provided code, the vulnerability can be fixed by checking if `val` is null before passing it to `strlen()`. Here is a possible fix:\n\n```cpp\nif (val != NULL) {\n    0 != hwloc_topology_set_xmlbuffer(opal_hwloc_topology, val, strlen(val) + 1);\n}\n```\n\n## Library Dependencies\n\nThe code example appears to depend on the `hwloc` library, which is used for portable hardware locality. It also uses standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "8896dcc1-0748-3127-b5c2-4966188c6c6f",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis identified a risk of undefined behavior due to possible overlapping memory regions between the source and destination in the memory copy operation. The destination and source expressions are both structure members, and dataflow analysis suggests that they may refer to overlapping memory. Additionally, the source may be null at this call site, which further increases the risk of undefined behavior. The classification explicitly states a risk of undefined behavior, and the verdict confirms this is a genuine issue. No evidence was found to suggest the destination is null, but the potential for source overlap and null source makes this a high-confidence finding.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove` instead of `memcpy`. This ensures that the copy operation is performed correctly even if the source and destination overlap.\n\n```c\nmemmove(&intf->if_addr, &ifr->ifr_addr, sizeof(struct sockaddr_in));\n```\n\nAdditionally, ensure that both the source and destination pointers are valid and not null before performing the copy to avoid null pointer dereference.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "ec367eb7-8aa2-329a-8ece-0521daa84b07",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. The `fopen` function is one of these prohibited functions. It is used to open a file, but it does not check for errors that could lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these prohibited functions. For `fopen`, a safer alternative could be `fopen_s` which is a part of the C11 standard. This function includes error handling and is therefore less likely to lead to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s`. Here is an example:\n\n```cpp\nFILE* file;\nerrno_t err = fopen_s(&file, \"file.txt\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdio.h` library.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b3e64c9c-6a51-332b-839a-a5ceba7b0448",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflow, format string vulnerabilities, integer overflow, etc. In this case, the `memmove()` function is used, which can lead to buffer overflow if the size of the source is larger than the destination.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In C++, use the Standard Template Library (STL) functions and classes which are generally safer and less prone to errors. Always validate and sanitize input data. Implement proper error handling.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove()` function with a safer alternative. In C++, you can use `std::copy()` from the STL. Here is how you can do it:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy(src, src + size, dest);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<algorithm>` for `std::copy()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "332f1830-7e19-3601-90f9-d50c35dcec37",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflow, format string vulnerabilities, integer overflow, etc. In this case, the `memmove()` function is used, which can lead to buffer overflow if the size of the source is larger than the destination.\n\n## Mitigation Advice\n\nAvoid using insecure C library functions. Instead, use safer alternatives provided by the language. In C++, use the Standard Template Library (STL) functions and classes which are generally safer and less prone to errors. Always validate and sanitize input data. Implement proper error handling.\n\n## Source Code Fix Recommendation\n\nReplace the `memmove()` function with a safer alternative. In C++, you can use `std::copy()` from the STL. Here is how you can do it:\n\n```cpp\n#include <algorithm>\n\n// ...\n\nstd::copy(src, src + size, dest);\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<algorithm>` for `std::copy()`\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "a520bc12-21e7-355b-8488-c47dd905f358",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 452,
                  "startColumn": 29,
                  "endLine": 452,
                  "endColumn": 60,
                  "charOffset": 11491,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq)",
                      "markdown": "`malloc(sizeof(custom_match_umq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11491,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c0bdc3bf-6fb1-34fa-82de-73dc3da1e0b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 15,
                  "endLine": 418,
                  "endColumn": 51,
                  "charOffset": 10762,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq_node)",
                      "markdown": "`malloc(sizeof(custom_match_umq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10762,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "05d5468d-cd8c-3a46-95af-5a7e30e2f7ee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 223,
                  "startColumn": 29,
                  "endLine": 223,
                  "endColumn": 60,
                  "charOffset": 5552,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq)",
                      "markdown": "`malloc(sizeof(custom_match_prq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5552,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2ac6931a-0eca-3404-abc8-060a2a8967ef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 15,
                  "endLine": 187,
                  "endColumn": 51,
                  "charOffset": 4805,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq_node)",
                      "markdown": "`malloc(sizeof(custom_match_prq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_linkedlist.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4805,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "18a2966d-3ac5-32ea-b58d-041aa3f5e974",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 29,
                  "endLine": 519,
                  "endColumn": 60,
                  "charOffset": 14672,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq)",
                      "markdown": "`malloc(sizeof(custom_match_umq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14672,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "aa0da565-8353-3a7b-a56a-0db467db118e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 479,
                  "startColumn": 19,
                  "endLine": 479,
                  "endColumn": 55,
                  "charOffset": 13676,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_umq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_umq_node)",
                      "markdown": "`malloc(sizeof(custom_match_umq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13676,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6377e878-8009-3d0d-8f66-3d682ef4bb7a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 29,
                  "endLine": 266,
                  "endColumn": 60,
                  "charOffset": 7724,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq)",
                      "markdown": "`malloc(sizeof(custom_match_prq)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7724,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "79cbefea-e49d-3b47-9f32-43371426a25d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                },
                "region": {
                  "startLine": 217,
                  "startColumn": 19,
                  "endLine": 217,
                  "endColumn": 55,
                  "charOffset": 6477,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(custom_match_prq_node)",
                    "rendered": {
                      "text": "malloc(sizeof(custom_match_prq_node)",
                      "markdown": "`malloc(sizeof(custom_match_prq_node)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mca/pml/ob1/custommatch/pml_ob1_custom_match_arrays.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6477,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "73003818-f60a-3e31-912d-4313942d3070",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 979,
                  "startColumn": 9,
                  "endLine": 979,
                  "endColumn": 44,
                  "charOffset": 29181,
                  "charLength": 35,
                  "snippet": {
                    "text": "strcpy (error_buf, \"Unknown error\")",
                    "rendered": {
                      "text": "strcpy (error_buf, \"Unknown error\")",
                      "markdown": "`strcpy (error_buf, \"Unknown error\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29181,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error_buf, <size of error_buf>,  \"Unknown error\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29181,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "strlcpy(error_buf,  \"Unknown error\", <size of error_buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "6f35c391-2324-3eb3-b83b-93953d477ef5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 977,
                  "startColumn": 9,
                  "endLine": 977,
                  "endColumn": 34,
                  "charOffset": 29134,
                  "charLength": 25,
                  "snippet": {
                    "text": "strcpy (error_buf, error)",
                    "rendered": {
                      "text": "strcpy (error_buf, error)",
                      "markdown": "`strcpy (error_buf, error)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29134,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error_buf, <size of error_buf>,  error)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29134,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlcpy(error_buf,  error, <size of error_buf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ac73c548-2b6b-3575-838e-8f06d9602944",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 964,
                  "startColumn": 3,
                  "endLine": 964,
                  "endColumn": 46,
                  "charOffset": 28906,
                  "charLength": 43,
                  "snippet": {
                    "text": "strcpy (error, \"Memory allocation failure\")",
                    "rendered": {
                      "text": "strcpy (error, \"Memory allocation failure\")",
                      "markdown": "`strcpy (error, \"Memory allocation failure\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28906,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strcpy_s(error, <size of error>,  \"Memory allocation failure\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28906,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlcpy(error,  \"Memory allocation failure\", <size of error>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "04388287-058b-3db8-b7a0-9c761950935d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 36,
                  "endLine": 109,
                  "endColumn": 49,
                  "charOffset": 3350,
                  "charLength": 13,
                  "snippet": {
                    "text": "malloc (size)",
                    "rendered": {
                      "text": "malloc (size)",
                      "markdown": "`malloc (size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3350,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "69ad8698-efb1-3cec-909d-5a1ce46d644c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/util/json/3rd-party/json.c"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 3,
                  "endLine": 283,
                  "endColumn": 60,
                  "charOffset": 7782,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy (&state.settings, settings, sizeof (json_settings)",
                    "rendered": {
                      "text": "memcpy (&state.settings, settings, sizeof (json_settings)",
                      "markdown": "`memcpy (&state.settings, settings, sizeof (json_settings)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/util/json/3rd-party/json.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7782,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&state.settings, <size of &state.settings>,  settings,  sizeof (json_settings)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f5ea93f0-e1e1-3830-8c9e-3563b70eab6e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 12,
                  "endLine": 120,
                  "endColumn": 38,
                  "charOffset": 3773,
                  "charLength": 26,
                  "snippet": {
                    "text": "memcpy(base, *source, len)",
                    "rendered": {
                      "text": "memcpy(base, *source, len)",
                      "markdown": "`memcpy(base, *source, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3773,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "memcpy_s(base, <size of base>,  *source,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d68713bf-4373-3d89-a9ec-dd866e2c3572",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 12,
                  "endLine": 103,
                  "endColumn": 36,
                  "charOffset": 3251,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(*dest, base, len)",
                    "rendered": {
                      "text": "memcpy(*dest, base, len)",
                      "markdown": "`memcpy(*dest, base, len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3251,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(*dest, <size of *dest>,  base,  len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "391c6c2f-b32e-3b4c-8180-8853e1125f0f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 21,
                  "endLine": 69,
                  "endColumn": 33,
                  "charOffset": 3216,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3216,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4d7a9e8e-fe49-35d8-ac21-0f42d127b4b6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 21,
                  "endLine": 52,
                  "endColumn": 33,
                  "charOffset": 2089,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/ts.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2089,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ccd0dfeb-9b69-33a2-885e-c65a1455afaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                },
                "region": {
                  "startLine": 456,
                  "startColumn": 22,
                  "endLine": 456,
                  "endColumn": 33,
                  "charOffset": 13764,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(ptr)",
                    "rendered": {
                      "text": "strlen(ptr)",
                      "markdown": "`strlen(ptr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13764,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(ptr, <size of ptr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13764,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(ptr, <size of ptr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "6cfabbbe-c533-3242-8dd0-5110ce9c1e1f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/memory/patcher/memory_patcher_component.c"
                },
                "region": {
                  "startLine": 457,
                  "startColumn": 8,
                  "endLine": 457,
                  "endColumn": 15,
                  "charOffset": 13785,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9a64283f-4b0a-36b3-af3d-e229000f8cb0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ompi/mpi/fortran/use-mpi-f08/base/bigcount.h"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 26,
                  "endLine": 20,
                  "endColumn": 51,
                  "charOffset": 471,
                  "charLength": 25,
                  "snippet": {
                    "text": "malloc(sizeof(*tmp_array)",
                    "rendered": {
                      "text": "malloc(sizeof(*tmp_array)",
                      "markdown": "`malloc(sizeof(*tmp_array)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "ompi/mpi/fortran/use-mpi-f08/base/bigcount.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 471,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "deb3cc19-78b0-3a65-a972-d07e305df24b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 689,
                  "startColumn": 60,
                  "endLine": 689,
                  "endColumn": 85,
                  "charOffset": 23963,
                  "charLength": 25,
                  "snippet": {
                    "text": "strlen(distances[i].uuid)",
                    "rendered": {
                      "text": "strlen(distances[i].uuid)",
                      "markdown": "`strlen(distances[i].uuid)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23963,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strlen_s(distances[i].uuid, <size of distances[i].uuid>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23963,
                        "charLength": 25
                      },
                      "insertedContent": {
                        "text": "strnlen(distances[i].uuid, <size of distances[i].uuid>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e0159aef-10e2-3382-825b-92badd0d4b79",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 295,
                  "startColumn": 79,
                  "endLine": 295,
                  "endColumn": 91,
                  "charOffset": 8908,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(name)",
                    "rendered": {
                      "text": "strlen(name)",
                      "markdown": "`strlen(name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8908,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8908,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4c43e63f-701d-3bd3-92e3-1135a4b4e791",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ofi/common_ofi.c"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 44,
                  "endLine": 277,
                  "endColumn": 59,
                  "charOffset": 8455,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(list[i])",
                    "rendered": {
                      "text": "strlen(list[i])",
                      "markdown": "`strlen(list[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8455,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(list[i], <size of list[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/common/ofi/common_ofi.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8455,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(list[i], <size of list[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "df25b02b-891e-3cda-a2b8-5d77c9ec4fec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 31,
                  "endLine": 106,
                  "endColumn": 46,
                  "charOffset": 4781,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(destdir)",
                    "rendered": {
                      "text": "strlen(destdir)",
                      "markdown": "`strlen(destdir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4781,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4781,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4ce55ee2-c447-35c3-85ab-074f1fbc43e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 111,
                  "startColumn": 10,
                  "endLine": 111,
                  "endColumn": 23,
                  "charOffset": 4877,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(input)",
                    "rendered": {
                      "text": "strlen(input)",
                      "markdown": "`strlen(input)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4877,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4877,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "74c48fc3-ccec-3968-8bae-b5f2a29dec11",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 29,
                  "endLine": 107,
                  "endColumn": 44,
                  "charOffset": 4833,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(destdir)",
                    "rendered": {
                      "text": "strlen(destdir)",
                      "markdown": "`strlen(destdir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4833,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4833,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(destdir, <size of destdir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "0d9aa21e-d20f-32fb-8675-7efa9aec838e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ucx/common_ucx.c"
                },
                "region": {
                  "startLine": 327,
                  "startColumn": 14,
                  "endLine": 327,
                  "endColumn": 20,
                  "charOffset": 12965,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b93671c9-16dd-3436-9638-adea641cdb2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ucx/common_ucx.c"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 80,
                  "endLine": 236,
                  "endColumn": 88,
                  "charOffset": 9633,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fe5b4ff2-9433-3d4a-a3ec-9fd71a44cb25",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ucx/common_ucx.c"
                },
                "region": {
                  "startLine": 225,
                  "startColumn": 10,
                  "endLine": 225,
                  "endColumn": 16,
                  "charOffset": 9153,
                  "charLength": 6,
                  "snippet": {
                    "text": "sscanf",
                    "rendered": {
                      "text": "sscanf",
                      "markdown": "`sscanf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c6954dfa-9224-3cf7-a6ba-d58c1e581409",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/common/ucx/common_ucx.c"
                },
                "region": {
                  "startLine": 311,
                  "startColumn": 31,
                  "endLine": 311,
                  "endColumn": 39,
                  "charOffset": 12317,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1b9df3e9-0b5d-3f22-8147-7003b91e3b9c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 34,
                  "endLine": 44,
                  "endColumn": 61,
                  "charOffset": 2307,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(\"@{\" #fieldname \"}\")",
                    "rendered": {
                      "text": "strlen(\"@{\" #fieldname \"}\")",
                      "markdown": "`strlen(\"@{\" #fieldname \"}\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2307,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"@{\" #fieldname \"}\", <size of \"@{\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2307,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(\"@{\" #fieldname \"}\", <size of \"@{\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "dd4f8618-b241-32fc-abb7-e755939860fe",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 18,
                  "endLine": 105,
                  "endColumn": 24,
                  "charOffset": 4726,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e48d881e-c650-38d5-94b8-c57e47e1e7c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 34,
                  "endLine": 36,
                  "endColumn": 61,
                  "charOffset": 1531,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(\"${\" #fieldname \"}\")",
                    "rendered": {
                      "text": "strlen(\"${\" #fieldname \"}\")",
                      "markdown": "`strlen(\"${\" #fieldname \"}\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1531,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"${\" #fieldname \"}\", <size of \"${\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/installdirs/base/installdirs_base_expand.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1531,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(\"${\" #fieldname \"}\", <size of \"${\" #fieldname \"}\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "75414095-8db6-3dff-ba1a-e7d2a0f87128",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 4,
                  "endLine": 107,
                  "endColumn": 11,
                  "charOffset": 6088,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "44190b36-699f-3917-910f-4ee3174d05db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 106,
                  "startColumn": 4,
                  "endLine": 106,
                  "endColumn": 11,
                  "charOffset": 6014,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "99b61587-aa2b-38f9-b09c-2ccdc4f6b022",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 4,
                  "endLine": 104,
                  "endColumn": 11,
                  "charOffset": 5868,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ba32caf8-80d1-3122-9d39-aa425481abb9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 105,
                  "startColumn": 4,
                  "endLine": 105,
                  "endColumn": 11,
                  "charOffset": 5939,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a833f709-fae5-302f-8202-89043901d01c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 102,
                  "startColumn": 4,
                  "endLine": 102,
                  "endColumn": 11,
                  "charOffset": 5721,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "15df7a07-55af-3d6c-88d0-6ab67d819b78",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 4,
                  "endLine": 100,
                  "endColumn": 11,
                  "charOffset": 5572,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "037ca1bd-9e0b-3a45-ae0e-96303e7a0abf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 4,
                  "endLine": 103,
                  "endColumn": 11,
                  "charOffset": 5796,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "381b991c-4b2d-30ad-be5f-841a10cbe1f6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 4,
                  "endLine": 101,
                  "endColumn": 11,
                  "charOffset": 5650,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2ea583ed-ed37-3f26-b5c1-e3a75cf67bbd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 99,
                  "startColumn": 4,
                  "endLine": 99,
                  "endColumn": 11,
                  "charOffset": 5493,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e3284542-7cd5-3e08-afa7-a3b8739b59bc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 98,
                  "startColumn": 4,
                  "endLine": 98,
                  "endColumn": 11,
                  "charOffset": 5418,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dd4b5822-f86a-3da2-b756-df995b852f55",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 4,
                  "endLine": 97,
                  "endColumn": 11,
                  "charOffset": 5346,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e5fbd770-f8e4-307f-b19d-d44fe90cbe0f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 4,
                  "endLine": 96,
                  "endColumn": 11,
                  "charOffset": 5270,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "72641361-0773-324e-8bf2-a0d85244da2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 4,
                  "endLine": 95,
                  "endColumn": 11,
                  "charOffset": 5195,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "fe67f9df-9613-30d0-a5cc-b60f57b16449",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 4,
                  "endLine": 94,
                  "endColumn": 11,
                  "charOffset": 5123,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "422dde12-c713-3135-b2d4-fb4593ba5d5f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 91,
                  "startColumn": 4,
                  "endLine": 91,
                  "endColumn": 11,
                  "charOffset": 4905,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "30071bea-d386-317b-ba29-bf2c5b49c076",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 4,
                  "endLine": 93,
                  "endColumn": 11,
                  "charOffset": 5052,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3d8625c1-7582-3154-a30e-ca50ca2ea4ed",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/installdirs/base/installdirs_base_components.c"
                },
                "region": {
                  "startLine": 92,
                  "startColumn": 4,
                  "endLine": 92,
                  "endColumn": 11,
                  "charOffset": 4976,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b815fbd1-1ea3-3366-8a52-3a98c8e82658",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/xpmem/smsc_xpmem_module.c"
                },
                "region": {
                  "startLine": 288,
                  "startColumn": 8,
                  "endLine": 288,
                  "endColumn": 35,
                  "charOffset": 11686,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, copy_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, copy_size)",
                      "markdown": "`memcpy(dst, src, copy_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/smsc/xpmem/smsc_xpmem_module.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11686,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  copy_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ac3b5122-538b-36fa-bce7-6b9c72b42046",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/knem/smsc_knem_component.c"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 62,
                  "endLine": 93,
                  "endColumn": 70,
                  "charOffset": 3240,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "e1de7daa-cd26-33a8-a127-015854f821da",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/linux_ipv6/if_linux_ipv6.c"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 13,
                  "endLine": 112,
                  "endColumn": 18,
                  "charOffset": 2710,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "24474ff0-1e29-3eeb-b2fc-1745ded73b1a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/bsdx_ipv4/if_bsdx.c"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 8,
                  "endLine": 117,
                  "endColumn": 65,
                  "charOffset": 3271,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(&a4, &(sin_addr->sin_addr), sizeof(struct in_addr)",
                    "rendered": {
                      "text": "memcpy(&a4, &(sin_addr->sin_addr), sizeof(struct in_addr)",
                      "markdown": "`memcpy(&a4, &(sin_addr->sin_addr), sizeof(struct in_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/bsdx_ipv4/if_bsdx.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3271,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&a4, <size of &a4>,  &(sin_addr->sin_addr),  sizeof(struct in_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e166c239-4613-382d-8968-3f59fe22fca3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                },
                "region": {
                  "startLine": 169,
                  "startColumn": 8,
                  "endLine": 169,
                  "endColumn": 67,
                  "charOffset": 5628,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(&a6, &(sin_addr->sin6_addr), sizeof(struct in6_addr)",
                    "rendered": {
                      "text": "memcpy(&a6, &(sin_addr->sin6_addr), sizeof(struct in6_addr)",
                      "markdown": "`memcpy(&a6, &(sin_addr->sin6_addr), sizeof(struct in6_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5628,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&a6, <size of &a6>,  &(sin_addr->sin6_addr),  sizeof(struct in6_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "28d97cdc-2d97-3a00-81a9-2fd90c4e9b17",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                },
                "region": {
                  "startLine": 161,
                  "startColumn": 39,
                  "endLine": 161,
                  "endColumn": 63,
                  "charOffset": 5282,
                  "charLength": 24,
                  "snippet": {
                    "text": "malloc(48 * sizeof(char)",
                    "rendered": {
                      "text": "malloc(48 * sizeof(char)",
                      "markdown": "`malloc(48 * sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5282,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "73f00766-dfba-317b-a42d-eb2b3db79ccd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 37,
                  "endLine": 96,
                  "endColumn": 68,
                  "charOffset": 2370,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(sizeof(struct ifaddrs *)",
                    "rendered": {
                      "text": "malloc(sizeof(struct ifaddrs *)",
                      "markdown": "`malloc(sizeof(struct ifaddrs *)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/bsdx_ipv6/if_bsdx_ipv6.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2370,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9fd2c352-6b51-3d8b-b105-315b30c0a746",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 25,
                  "endLine": 103,
                  "endColumn": 40,
                  "charOffset": 3009,
                  "charLength": 15,
                  "snippet": {
                    "text": "malloc(ifc_len)",
                    "rendered": {
                      "text": "malloc(ifc_len)",
                      "markdown": "`malloc(ifc_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3009,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "f91dbecf-114f-3ee7-9c9c-c5fe7fd121e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                },
                "region": {
                  "startLine": 272,
                  "startColumn": 8,
                  "endLine": 272,
                  "endColumn": 56,
                  "charOffset": 8658,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(intf->if_mac, ifr->ifr_hwaddr.sa_data, 6)",
                    "rendered": {
                      "text": "memcpy(intf->if_mac, ifr->ifr_hwaddr.sa_data, 6)",
                      "markdown": "`memcpy(intf->if_mac, ifr->ifr_hwaddr.sa_data, 6)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8658,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(intf->if_mac, <size of intf->if_mac>,  ifr->ifr_hwaddr.sa_data,  6)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1943ef41-0891-37a1-8bb5-96478ef01f57",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/xpmem/smsc_xpmem_component.c"
                },
                "region": {
                  "startLine": 109,
                  "startColumn": 15,
                  "endLine": 109,
                  "endColumn": 20,
                  "charOffset": 4424,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "dfcd4818-405b-3f51-b6f1-f0d5ea0f2018",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/accelerator/smsc_accelerator_module.c"
                },
                "region": {
                  "startLine": 181,
                  "startColumn": 8,
                  "endLine": 181,
                  "endColumn": 111,
                  "charOffset": 8006,
                  "charLength": 103,
                  "snippet": {
                    "text": "memcpy(reg->data.handle.accelerator, reg->gpu_reg->data.ipcHandle.handle, SMSC_ACCELERATOR_HANDLE_SIZE)",
                    "rendered": {
                      "text": "memcpy(reg->data.handle.accelerator, reg->gpu_reg->data.ipcHandle.handle, SMSC_ACCELERATOR_HANDLE_SIZE)",
                      "markdown": "`memcpy(reg->data.handle.accelerator, reg->gpu_reg->data.ipcHandle.handle, SMSC_ACCELERATOR_HANDLE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/smsc/accelerator/smsc_accelerator_module.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 8006,
                        "charLength": 103
                      },
                      "insertedContent": {
                        "text": "memcpy_s(reg->data.handle.accelerator, <size of reg->data.handle.accelerator>,  reg->gpu_reg->data.ipcHandle.handle,  SMSC_ACCELERATOR_HANDLE_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "61b3543d-9f86-3605-8786-f1de7b37ab4a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/accelerator/smsc_accelerator_module.c"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 4,
                  "endLine": 89,
                  "endColumn": 40,
                  "charOffset": 3220,
                  "charLength": 105,
                  "snippet": {
                    "text": "memcpy(&rget_reg.data.ipcHandle.handle, reg->handle.accelerator,\n           SMSC_ACCELERATOR_HANDLE_SIZE)",
                    "rendered": {
                      "text": "memcpy(&rget_reg.data.ipcHandle.handle, reg->handle.accelerator,\n           SMSC_ACCELERATOR_HANDLE_SIZE)",
                      "markdown": "`memcpy(&rget_reg.data.ipcHandle.handle, reg->handle.accelerator,\n           SMSC_ACCELERATOR_HANDLE_SIZE)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/smsc/accelerator/smsc_accelerator_module.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3220,
                        "charLength": 105
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&rget_reg.data.ipcHandle.handle, <size of &rget_reg.data.ipcHandle.handle>,  reg->handle.accelerator, \n           SMSC_ACCELERATOR_HANDLE_SIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c875fbbb-cffc-36fd-9d93-f2fae8aa1c6a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/smsc/cma/smsc_cma_module.c"
                },
                "region": {
                  "startLine": 81,
                  "startColumn": 61,
                  "endLine": 81,
                  "endColumn": 69,
                  "charOffset": 3223,
                  "charLength": 8,
                  "snippet": {
                    "text": "strerror",
                    "rendered": {
                      "text": "strerror",
                      "markdown": "`strerror`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "14d1017e-08f2-3a6a-93cc-07db1daa43bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/hwloc/base/hwloc_base_util.c"
                },
                "region": {
                  "startLine": 279,
                  "startColumn": 72,
                  "endLine": 279,
                  "endColumn": 83,
                  "charOffset": 9845,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(val)",
                    "rendered": {
                      "text": "strlen(val)",
                      "markdown": "`strlen(val)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/hwloc/base/hwloc_base_util.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9845,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(val, <size of val>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/hwloc/base/hwloc_base_util.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9845,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(val, <size of val>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "8896dcc1-0748-3127-b5c2-4966188c6c6f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                },
                "region": {
                  "startLine": 255,
                  "startColumn": 8,
                  "endLine": 255,
                  "endColumn": 73,
                  "charOffset": 7959,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(&intf->if_addr, &ifr->ifr_addr, sizeof(struct sockaddr_in)",
                    "rendered": {
                      "text": "memcpy(&intf->if_addr, &ifr->ifr_addr, sizeof(struct sockaddr_in)",
                      "markdown": "`memcpy(&intf->if_addr, &ifr->ifr_addr, sizeof(struct sockaddr_in)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "opal/mca/if/posix_ipv4/if_posix.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7959,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&intf->if_addr, <size of &intf->if_addr>,  &ifr->ifr_addr,  sizeof(struct sockaddr_in)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ec367eb7-8aa2-329a-8ece-0521daa84b07",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/hwloc/base/hwloc_base_util.c"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 29,
                  "endLine": 233,
                  "endColumn": 34,
                  "charOffset": 7830,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "b3e64c9c-6a51-332b-839a-a5ceba7b0448",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/accelerator/null/accelerator_null_component.c"
                },
                "region": {
                  "startLine": 267,
                  "startColumn": 4,
                  "endLine": 267,
                  "endColumn": 11,
                  "charOffset": 10542,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "332f1830-7e19-3601-90f9-d50c35dcec37",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "opal/mca/accelerator/null/accelerator_null_component.c"
                },
                "region": {
                  "startLine": 260,
                  "startColumn": 4,
                  "endLine": 260,
                  "endColumn": 11,
                  "charOffset": 10249,
                  "charLength": 7,
                  "snippet": {
                    "text": "memmove",
                    "rendered": {
                      "text": "memmove",
                      "markdown": "`memmove`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}